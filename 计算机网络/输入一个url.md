#### 浏览器输入一段url后发生了什么

- 判断是“合法的url”还是一个搜索关键字。

- 使用hsts进行安全访问（重点在于hsts和缓存策略，以及dns查询（通过操作系统）的过程）
- ![截屏2020-07-19 下午4.20.24](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-19 下午4.20.24.png)

#### hsts

正常我们输入url，浏览器默认以http形式向80端口发送请求（或者通过点击书签的格式）。收到302重定向后再以https发送请求。(有可能会遇到中间人攻击)

- 在服务器响应头中添加 `Strict-Transport-Security`，可以设置 `max-age`
- 用户访问时，服务器种下这个头
- 下次如果使用 http 访问，只要 max-age 未过期，客户端会进行内部跳转，可以看到 307 Redirect Internel 的响应码
- 变成 https 访问源服务器

避免SSL剥离攻击。**只要浏览器曾经与服务器创建过一次安全连接**，之后浏览器会强制使用HTTPS，即使链接被换成了HTTP。

避免假冒证书攻击。如果中间人使用自己的自签名证书来进行攻击，浏览器会给出警告，但是许多用户会忽略警告。HSTS解决了这一问题，一旦服务器发送了HSTS字段，用户将不再允许忽略警告。



HSTS preload list



如果浏览器证书错误，一般情况会提醒存在安全风险，然是依然给一个链接进入目标页，而 HSTS 则没有目标页入口，所以一旦证书配置错误，就是很大的故障了

### 含义

HSTS preload list是Chrome浏览器中的HSTS预载入列表，在该列表中的网站，使用Chrome浏览器访问时，会自动转换成HTTPS。Firefox、Safari、Edge浏览器也在采用这个列表

https://www.barretlee.com/blog/2015/10/22/hsts-intro/

作者：fina小姐
链接：https://www.jianshu.com/p/865ac44b9ee6
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

https://github.com/biaochenxuying/blog/issues/3

#### 输入地址

当我们开始在浏览器中输入网址的时候，浏览器其实就已经在智能的匹配可能得 url 了。它会从历史记录，书签等地方，找到已经输入的字符串可能对应的 url ，找到同输入的地址很匹配的项，然后给出智能提示，让你可以补全 url 地址。用户还没有按下 enter 键， 浏览器已经开始使用 DNS 预取技术解析该域名了。

对于 chrome 的浏览器，如果有该域名相关的缓存，它会直接从缓存中把网页展示出来，就是说，你还没有按下 enter，页面就出来了。如果没有缓存，就还是会重新请求资源。

#### dns查询

把url变成ip地址（强调54的udp端口号）

https://blog.51cto.com/zengestudy/2132511

![截屏2020-07-19 下午4.27.35](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-19 下午4.27.35.png)

- 1. 浏览器缓存**

  浏览器会先检查是否在缓存中，没有则调用系统库函数进行查询。

  **2. 操作系统缓存**

  会向检查域名是否存在本地的 Hosts 文件里，没有则向 DNS 服务器发送查询请求。

  **3. 路由器缓存**

  路由器也有自己的缓存。

  **4. ISP DNS 缓存**

  ISP DNS 就是在客户端电脑上设置的首选 DNS 服务器，它们在大多数情况下都会有缓存。

  ![截屏2020-07-19 下午4.27.50](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-19 下午4.27.50.png)



那么DNS Prefetching 是什么 ：

- DNS 提前去解析iphttps://lrita.github.io/2018/07/15/hash-tree-hamp/



- 浏览器使用生成http报文

- 运输层三次握手建立连接（强调初始随机序列号和timestamp）

- 通过dhcp（目的端口67，源端口68获得这个ip地址）

- ip层通过bgp协议把这个报文通过指定的as-path发送的网关，通过ospf在一个as内部找到到这个网关的下一跳路径。

- 使用arp地址解析协议查找mac地址。

- 然后到达了对面服务器后，可能会使用nat协议具体到对应的服务器。

- ssl层两次握手建立https连接（强调dh更安全）（强调ssl关闭（必须强调））

  



#### http层

说明get请求和post的请求的区别：

get获取，post提交更新资源



注意tcp和quic协议的竞争。



以及状态吗100 continue和401请求为满足。



最好带上http1.1和http2。

就是多路复用

（说明对于github的）（要说明对于某些请求，会用quic和tcp进行竞争）

然后如果对于https的可能会用443端口发送数据。

之后主要包括一些状态吗和首部。

像一些重要的首部比如说：

用于处理cach的首部：etag和if-nonematch（用来获取最新的数据）

（cache-control用来控制缓存策略数据能否存在）（还有vary进行缓存服务器筛选）

通过content-encoding：返回加密类型。



还有cookie和set-cookie这种身份鉴别机制：

（强调github的session策略）

```
expires：指定过期时间（到期后自动删除）。

SECURE:表明cookie只能通过https传递。

httponly：为了防止xss攻击，javascript的通过JavaScript的 [`Document.cookie`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie) API无法访问带有 `HttpOnly` 标记的Cookie，

Path：表示了cookie的作用的url。（匹配子路径）

Same-site：

strict：

只有当前网页和发出请求的网页一样时才会带上cookie。（防止csrf攻击（伪造带有正确cookie的http请求））

lax：能让get请求发送。
```

还有一些处理安全连接的：

upgrade-insecure-requests：

x-xss-protection：检测跨站脚本攻击

```
X-Content-Type-Options: nosniff（阻止和contnt-type不一样的style和script）
```

```
X-Frame-Options：网页不能以iframe框架的形式显示。
```

expect-ct：强调证书也不是绝对安全的。



强调服务器端的一些响应头以应对这个xss攻击

```
### 1. Sec-Fetch-Dest

代表這個請求的目的地是哪裡。

可能的值有 audio、document、font、image、object、serviceworker [等等](https://mikewest.github.io/sec-metadata/#sec-fetch-dest-header)。這樣有幾個好處，有了這些 header 的判斷，伺服器馬上就可以知道這個請求來源是否合法，例如如果這個來源是從 `` 來的，卻不是跟伺服器要圖片，那麼十之八九是駭客，我們就可以直接回應錯誤給他。



该**`Sec-Fetch-Dest`**取元数据报头指示该请求的目的地，即所获取的数据将如何使用。

### 2. Sec-Fetch-Mode

代表請求的模式。主要有 cors、navigate、nested-navigate、no-cors 等等，來判斷這個請求的模式是什麼，類似 `fetch` 當中的 mode。

像是 `Set-Fetch-User` 我們也可以知道使用者是否是透過操作（例如點擊、鍵盤等等）來發出請求的。

### 3. Sec-Fetch-Site

代表請求的來源是同源還是跨域。
```



#### 服务器

服务器通常通过每次收到一个请求都开启一个协程去处理。



看是否会重定向。



收到请求时，看一下请求的对应文件路径存不存在，如果存在，再查看是否支持指定的比如get或者post方法。

如果支持就会调用对应的请求处理方法。

服务器还会把这个四元组连接给cache到内存里头，方便下次访问。



#### 浏览器接受到响应后

浏览器接收到来自服务器的响应资源后，会对资源进行分析。

首先查看 Response header，根据不同状态码做不同的事（比如上面提到的重定向）。

如果响应资源进行了压缩（比如 gzip），还需要进行解压。

然后，对响应资源做缓存。

接下来，根据响应资源里的 [MIME](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types) 类型去解析响应内容（比如 HTML、Image各有不同的解析方式）。





比方说chunked分块传输



Content distribution network(can)

![截屏2020-07-19 下午9.00.53](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-19 下午9.00.53.png)

通常，我们使用cdn和cache处理hot数据。

使用hystack处理长尾请求。（核心是多个照片存储在一个文件里头）



如图，当我们向一个服务器去请求数据时。（读取）

比如图片数据。其中可能有一个庞大的分布式集群。

首先跟服务器沟通。

服务器通过一个目录为每个请求构建一个url，指定从最近的cdn服务器或者直接从cache中读取，这个url还包括具体的机器id，以及这个文件存在的逻辑卷以及photo的唯一标识符。（逻辑卷（因为一个文件通常存储在多个机器上，所以逻辑卷通常映射到多个物理上的机器））

然后cdn中如果找不到，就从cache中读取，cache中找不到再从具体的机器中读取，比如磁盘。



目录负责：

- 逻辑卷到物理卷的映射，给服务区构建url使用
- 在各个物理机器上平衡读，在逻辑卷上平衡写。（注意平衡读和写的范畴）。
- 在cdn和cache中平衡读，让我们调整cdn负载
- 标记那些只读机器



#### cache

对于cache，我们可以使用一致性hash构建一个cache，然后再其上有照片的唯一标识符查找。

然后cache是有限的对吧。

因此我们只对那些

（1）直接来自用户请求的数据而不是cdn（cdn后缓存无效，cdn未命中的请求不太可能进入内部缓存）

（2）从启用了写功能的机器上的读取请求（我们标记机器为可读可写的（新机器），容量用光了我们就标记为只读的）（是在写入后不久的照片往往之后读取也是最多的，因为照片这种数据的访问热度往往和创建时间成正比；将写机器过滤掉读请求，因为机器往往是要么写要么读效率都很高，但是读写混合效率就会下降）



##### store

每一个superblock表示一个物理卷，通常100g左右。

而needele是保存实际照片的地方。

我们通常在内存中保存（key， alternative key（身份证（文件拥有者）））到（flags，size和offset（在物理卷上的偏移））。

重点啊就是元数据要够小，不要像inode那样536b，内存中放不下哦。（实际元数据32b）



而niddle是文件上传时候随机创建的值，避免url猜测攻击。

读取文件的时候携带这个cookie，只有当cookie和保存的一致的时候才会返回。



#### 传统的方法

一个目录中存储几千个文件啊，目录太大就会很慢。

依然需要三个磁盘io：

将目录元数据加载到磁盘。

将inode读取到内存。

将文件元数据读取。



我们可以内存中缓存inode，但是问题在于其实对于热点数据啊直接cache就能处理。

而图片主要有个长尾问题-就是时间过去很久这张图片还是会被经常访问。

（那么只能存储所有的元数据到磁盘，但是inode是536b，而图片呢，甚至可能没有536kb。性价比低）



![截屏2020-07-19 下午9.32.13](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-19 下午9.32.13.png)

- 我们写的时候吧文件附加在superblock的末尾
- 通常删除只是附加一个删除标志位

![截屏2020-07-19 下午9.03.47](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-19 下午9.03.47.png)

cache时内部cdn，让我们的请求能够拦截住大多数的最流行的图片然后当外部cdn失败的时候可以从cache里头提取数据。



1. 所有的写操作都是时append写操作，需要一次磁盘IO完成。
2. 如果index file都可以加载在内存里，读操作也只需要一次IO操作完成。
3. 删除操作需要2次IO操作：一次读取IO，一次写入IO。在haystack里，删除操作很少，可以接受。（一次从needle中找到数据并读取，第二次把数据写回）
4. 更新操作这里没有实现。只能用 删除+写操作完成，代价比较大

https://zhuanlan.zhihu.com/p/136705670



#### 温存储

 Facebook 的语境下，也就是用户在账户里上传的的图片，视频以及文档等数据，这些数据具有*一次创建，多次读取，不会修改，偶尔删除* 的特点。

对于blob，太多了的话，三节点备份，其实代价比较高。



温暖数据：请求和删除速率均很低。

请求在一周内就会下降一个数量级别。

#### 存储系统设计

索引文件是
存储机的内存中查找结构。它的
主要目的是允许重新启动的计算机快速运行
重建其内存索引。日记文件
跟踪已删除的BLOB；而在
原始版本的Haystack，删除操作由
直接更新数据和索引文件。对于锁定
卷，数据和索引文件是只读的，而
日志文件是可读写的。对于解锁的卷，全部三个
文件是可读写的。

- 通过用一个删除文件不需要两次io一个删除。
- 然后现在我们通过频繁的数据重新整合提高速率

![截屏2020-07-19 下午10.09.03](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-19 下午10.09.03.png)

![截屏2020-07-19 下午10.06.46](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-19 下午10.06.46.png)

然后论文探讨了区分**热数据**和**温数据**的一个界限，通过对访问频次和删除频次随着创建时间的变化的分析，对于大部分 BLOG，得到了一个的大概值：一个月。但是有两个例外，一个是用户头像，一直是热数据；另外一个普通图片，使用三个月作为阈值。



Haystack 通过在一个数据中心的不同机架上各放一个副本，然后再不同数据中心再放一个副本的三副本策略获得了对硬盘，主机，机架甚至数据中心的容错能力。然后通过 RAID-6（1.2倍冗余数据编码，能够小范围的纠正错误，可以读读纠错码之类的文章）进行额外的硬盘容错，更上一层保险。但是付出的代价是 3*1.2 = 3.6 倍的有效冗余因子，这也是 Haystack 的局限之处，虽然最大化了 IOPS，但是在存储使用上却并不高效，造成了很多 BLOB 的数据冗余



F4,能够容忍4个快的错误。

数据文件用 n=10, k = 4 的里所码进行编码。具体来说，将每个数据文件切分为 n 个连续的数据块（block），每个具有固定尺寸 b（最后一个块不满，而又写不进去一个新 BLOB 的情况下，在结尾补零，***类似这种打 padding 也是数据对齐常用的手法\***）；对于每 n 个这样的块，生成 k 个同样尺寸的*奇偶校验块*（parity block），这样 n+k 个数据块构成一个逻辑上的 *条带*（stripe）。同一条带上的任意两个块互称为**兄弟块**（companion block）。正常读取时，可以直接从数据块中读（我猜是那n个块，不用额外进行计算还原，有待考证，还得看里所码原理以及具体实现）。如果某些块不可用了，就会在同一条带上任取 n 块，解码后还原；此外还有个性质，就是读取 n 个 block 上对应的 n 截数据（比如某个 BLOB），也可以进行解码（这两个性质都是编码决定的，类似于 n 元线性方程组，有 k 个冗余方程）。




由于每个 BLOB 都是加密过的，其秘钥放在额外的存储，通常是数据库中。通过删除其秘钥就可以达到事实上的 BLOB 的删除，这样就避免了数据紧缩（为什么可以不回收那些删除空间呢，毕竟对于文存储，删除量只有很小一部分，之前的温存储的假设就用在这里）；同时也省去了用备忘文件（journal file）来追踪删除信息。



最后，在两个不同数据中心的将所有数据块配对后，进行异或（XOR）操作，得到一个异或结果，放在第三个数据中心。这样，这三个数据中心的任何数据条带损坏到 RS 码都无法拯救的情况下（比如有四个以上机架出问题了），就可以通过其他两个数据中心数据进行 XOR 操作来抢救一下。

（1.4 * 3 / 2 ）= 2.1

https://zhuanlan.zhihu.com/p/61552666

https://zhuanlan.zhihu.com/p/61552666



#### html解析

- 将二进制文本utf-8编码
- 对于遇到的图片啊进行预请求
- 词法分析识别出token
- 构建出dom树
- ![截屏2020-07-19 下午11.24.21](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-19 下午11.24.21.png)

如果遇到静态资源，link标签则去请求相应的资源（强调这个请求是异步的）。

遇到script标签就会调用js引擎解释并执行（全局执行js代码的时候，dom树是禁止被访问的，因为js也可以操作dom结构，此时dom树并没有创建完成，所以js我们大都建议放在body元素之后（因为有些js执行期间可能会很耗时），这样就不会阻止其他资源的下载）。
————————————————
版权声明：本文为CSDN博主「李晓nic」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_42128813/java/article/details/103556398

#### css

一旦浏览器下载了 CSS，CSS 解析器就会处理它遇到的任何 CSS，根据[语法规范](https://drafts.csswg.org/css-syntax-3/)解析出所有的 CSS 并进行标记化，然后我们得到一个规则表。

**CSS 匹配规则**

在匹配一个节点对应的 CSS 规则时，是按照从右到左的顺序的，例如：`div p { font-size :14px }`会先寻找所有的`p`标签然后判断它的父元素是否为`div`。

所以我们写 CSS 时，尽量用 id 和 class，千万不要过度层叠。

它根据元素的属性等，并从 DocumentRuleSets 类中获取规则集合，依次按照 ID、类别、标签等选择器信息逐次匹配获得元素的样式。（强调属性，以及选择器的顺序）

#### 构建rendor渲染树

为每个dom树节点计算css样式信息。

渲染树会忽略掉不需要被渲染的元素(display:none,head,meta...)；

渲染树与DOM树不同，渲染树中并没有head、display为none等不必显示的节点。



请注意 `visibility: hidden` 与 `display: none` 是不一样的。前者隐藏元素，但元素仍占据着布局空间（即将其渲染成一个空框），而后者 (`display: none`) 将元素从渲染树中完全移除，元素既不可见，也不是布局的组成部分。（强调这两个节点）



#### 布局

布局流程的输出是一个“盒模型”，它会精确地捕获每个元素在视口内的确切位置和尺寸：所有相对测量值都转换为屏幕上的绝对像素。

弄清对象在网页上的确切大小和位置。

![截屏2020-07-19 下午11.35.16](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-19 下午11.35.16.png)

然后遍历渲染树，调用渲染器的 paint() 方法在屏幕上显示其内容。



#### **5. 合并渲染层**

把以上绘制的所有图片合并，最终输出一张图片。

#### **6. 回流与重绘**

**回流(reflow)**

当浏览器发现某个部分发现变化影响了布局时，需要倒回去重新渲染，会从`html`标签开始递归往下，重新计算位置和大小。

## 回流 (Reflow)

当`Render Tree`中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。

会导致回流的操作：

- 页面首次渲染
- 浏览器窗口大小发生改变
- 元素尺寸或位置发生改变
- 元素内容变化（文字数量或图片大小等等）
- 元素字体大小变化
- 添加或者删除**可见**的`DOM`元素
- 激活`CSS`伪类（例如：`:hover`）
- 查询某些属性或调用某些方法

一些常用且会导致回流的属性和方法：

作者：腰花
链接：https://juejin.im/post/5a9923e9518825558251c96a
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 重绘 (Repaint)

当页面中元素样式的改变并不影响它在文档流中的位置时（例如：`color`、`background-color`、`visibility`等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。

**一句话：回流必将引起重绘，重绘不一定会引起回流。**



`display:none` 会触发回流，而 `visibility:hidden` 只会触发重绘



#### js事件循环

从上图我们可以看出，js主线程它是有一个执行栈的，所有的js代码都会在执行栈里运行。我们看看浏览器上的执行栈



![img](https://user-gold-cdn.xitu.io/2019/10/17/16dd55cd629fba03?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



在执行代码过程中，如果遇到一些异步代码(比如setTimeout,ajax,promise.then以及用户点击等操作),那么浏览器就会将这些代码放到另一个线程(在这里我们叫做幕后线程)中去执行，在前端由浏览器底层执行，在 node 端由 libuv 执行，这个线程的执行不阻塞主线程的执行，主线程继续执行栈中剩余的代码。

当幕后线程（background thread）里的代码执行完成后(比如setTimeout时间到了，ajax请求得到响应),该线程就会将它的回调函数放到任务队列（又称作事件队列、消息队列）中等待执行。而当主线程执行完栈中的所有代码后，它就会检查任务队列是否有任务要执行，如果有任务要执行的话，那么就将该任务放到执行栈中执行。如果当前任务队列为空的话，它就会一直循环等待任务到来。因此，这叫做事件循环。

作者：小黎也
链接：https://juejin.im/post/5da742936fb9a04e223333ff
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



那么，问题来了。如果任务队列中，有很多个任务的话，那么要先执行哪一个任务呢？ 其实(正如上图所示)，js是有两个任务队列的，一个叫做 Macrotask Queue(Task Queue) 大任务, 一个叫做 Microtask Queue 小任务

Macrotask 常见的任务：

- setTimeout
- setInterval
- setImmediate
- I/O
- 用户交互操作，UI渲染

Microtask 常见的任务：

- Promise(重点)
- process.nextTick(nodejs)
- Object.observe(不推荐使用)

那么，两者有什么具体的区别呢？或者说，如果两种任务同时出现的话，应该选择哪一个呢？

其实事件循环执行流程如下:

1. 检查 Macrotask 队列是否为空,若不为空，则进行下一步，若为空，则跳到3
2. 从 Macrotask 队列中取队首(在队列时间最长)的任务进去执行栈中执行(仅仅一个)，执行完后进入下一步
3. 检查 Microtask 队列是否为空，若不为空，则进入下一步，否则，跳到1（开始新的事件循环）
4. 从 Microtask 队列中取队首(在队列时间最长)的任务进去事件队列执行,执行完后，跳到3 其中，在执行代码过程中新增的microtask任务会在当前事件循环周期内执行，而新增的macrotask任务只能等到下一个事件循环才能执行了。

> 简而言之，一次事件循环只执行处于 Macrotask 队首的任务，执行完成后，立即执行 Microtask 队列中的所有任务。


作者：小黎也
链接：https://juejin.im/post/5da742936fb9a04e223333ff
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。![截屏2020-07-20 上午12.17.05](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-20 上午12.17.05.png)