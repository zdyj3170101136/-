大数据量 （100s TB级数据） 且有快速随机访问的需求

写密集型应用，每天写入量巨大，而相对读数量较小的应用 比如IM的历史消息，游戏的日志等等

不需要复杂查询条件来查询数据的应用 HBase只支持基于rowkey的查询，对于HBase来说，单条记录或者小范围的查询是可以接受的，大范围的查询由于分布式的原因，可能在性能上有点影响，HBase不适用与有join，多级索引，表关系复杂的数据模型

对性能和可靠性要求非常高的应用 由于HBase本身没有单点故障，可用性非常高。

数据量较大，而且增长量无法预估的应用，需要进行优雅的数据扩展的 HBase支持在线扩展，即使在一段时间内数据量呈井喷式增长，也可以通过HBase横向扩展来满足功能。

存储结构化和半结构化的数据

作者：贝聊科技
链接：https://juejin.im/post/5b6d62ddf265da0f491bd200
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



**不适用场景**：

- 在不同的文档上需要添加事务。Document-Oriented数据库并不支持文档间的事务
- 多个文档直接需要复杂查询，例如join



关系型数据库和NoSQL数据库的选型，往往需要考虑几个指标：

- 数据量
- 并发量
- 实时性
- 一致性要求
- 读写分布和类型
- 安全性
- 运维成本

常见软件系统数据库选型参考如下：

- 内部使用的管理型系统 如运营系统，数据量少，并发量小，首选考虑关系型
- 大流量系统 如电商单品页，后台考虑选关系型，前台考虑选内存型
- 日志型系统 原始数据考虑选列式，日志搜索考虑选倒排索引
- 搜索型系统 例如站内搜索，非通用搜索，如商品搜索，后台考虑选关系型，前台考虑选倒排索引
- 事务型系统 如库存，交易，记账，考虑选关系型型+缓存+一致性型协议
- 离线计算 如大量数据分析，考虑选列式或者关系型也可以
- 实时计算 如实时监控，可以考虑选内存型或者列式数据库

作者：贝聊科技
链接：https://juejin.im/post/5b6d62ddf265da0f491bd200
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。





- 适用场景 储存用户信息(比如会话)、配置文件、参数、购物车等等。这些信息一般都和ID（键）挂钩

- 不适用场景
  - 需要通过值来查询，而不是键来查询。Key-Value数据库中根本没有通过值查询的途径。
  - 需要储存数据之间的关系。在Key-Value数据库中不能通过两个或以上的键来关联数据
  - 需要事务的支持。在Key-Value数据库中故障产生时不可以进行回滚。


作者：贝聊科技
链接：https://juejin.im/post/5b6d62ddf265da0f491bd200
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



#### cgo

https://dave.cheney.net/2016/01/18/cgo-is-not-go

### 部署变得更加复杂

关于向普通观众的任何演讲将至少包含一张带有以下单词的幻灯片：

> 单个静态二进制

这是Go的王牌，使它成为远离虚拟机和托管运行时的代言人。使用cgo，您就放弃了。



假设你有一个mysql程序要部署到一万台机器上，这些机器并不是同一批次购买和安装系统的，有的动态库是5.6的，有的是5.3的，还有的是4.5的，而且这些机器上分别有不同的程序依赖它们各自版本的动态库。然而你的代码是在5.5的环境下编译的，如果是动态链接，你打算如何部署？



作者：渔村Rider
链接：https://www.zhihu.com/question/38141184/answer/250822019
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



Go代码和C代码必须就如何共享地址空间，信号处理程序和线程TLS插槽等资源达成共识，当我同意时，我的意思是Go必须围绕C代码的假设进行工作。可以假定它始终在一个线程上运行的C代码，或者根本不准备在多线程环境中工作的C代码。



### 性能永远是一个问题

C代码和Go代码生活在两个不同的世界中，cgo穿越了它们之间的边界。这种转换不是免费的，并且取决于代码中的位置，其代价可能是无关紧要的，也可能是巨大的。

C对Go的调用约定或可增长堆栈一无所知，因此对C代码的调用必须记录goroutine堆栈的所有详细信息，切换到C堆栈，并运行不知道如何调用它的C代码。 ，或负责该程序的较大的Go运行时。

公平地说，Go也不了解C的世界。这就是为什么随着时间的推移，在两者之间传递数据的规则会变得更加繁琐的原因，因为编译器会更好地发现不再被视为活动的堆栈数据，而垃圾收集器也会对堆执行相同的操作。

如果在C Universe中出现故障，则Go代码必须恢复足够的状态以至少打印堆栈跟踪并干净地退出程序，而不是对核心文件进行处理。

在调用堆栈之间管理这种过渡，尤其是在涉及信号，线程和回调的地方，管理微不足道，并且Ian Lance Taylor再次在Go 1.6中做了大量工作，以改善信号处理与C的互操作性。

可以理解的是，C语言和Go语言世界之间的转换是微不足道的，并且永远不会没有开销



### 交叉编译不见了

Go对交叉编译的支持是同类中最好的。从[Go 1.5开始，您可以](http://dave.cheney.net/2015/08/22/cross-compilation-with-go-1-5)使用Go项目网站上提供的官方安装程序，从任何受支持的平台[交叉编译](http://dave.cheney.net/2015/08/22/cross-compilation-with-go-1-5)到任何其他平台。

默认情况下，交叉编译时cgo是禁用的。如果您的项目是纯Go语言，通常这不是问题。当混入对C库的依赖时，要么必须放弃交叉编译产品的选项，要么必须花费时间为所有目标查找和维护交叉编译C工具链。

也许，如果您开发的产品仅通过TCP套接字与客户端通信，并且打算在SaaS模型中运行它，那么可以说您不在乎交叉编译。但是，如果您要制造一种将供他人使用的产品，并且可能集成到他们的产品中，则可能是监视解决方案，或者可能是SaaS服务的客户端，那么您就无法使用它们进行交叉编译了。

Go支持的平台数量继续增长。Go 1.5增加了对64位ARM和PowerPC的支持。Go 1.6增加了对64位MIPS的支持，IBM的s390体系结构被推崇为Go 1.7。RISC-V正在开发中。如果您的产品依赖于C库，则不仅会遇到上述交叉编译的所有问题，而且还必须确保所依赖的C代码在Go支持的新平台上可靠地工作-并且您必须C / Go混合型为您提供了有限的可调试性。这使我想到了下一个要点。



### 建造时间更短

当`import "C"`您进入Go包时，`go build`必须做更多的工作来构建代码。构建软件包不再只是将`.go`范围内所有文件的列表传递给的单个调用`go tool compile`，而是：

- 需要调用cgo工具来生成C to Go和Go to C thunk和stub。
- 必须为程序包中的每个C文件调用系统C编译器。
- 各个编译单元组合在一起成为单个.o文件。
- 生成的.o文件通过系统链接器进行访问，以针对它们引用的共享库进行修复。

所有这些工作都是在每次编译或测试程序包时进行的，如果您正在该程序包中进行积极的工作，则这是持续不断的。Go工具在可能的情况下将其中的一些工作并行化，但是您的程序包的编译时间才增加了，包括了对所有C代码的完全重建。

可以通过将cgo垫片推入自己的程序包中来解决此问题，从而避免编译时的麻烦，但是现在您不得不重新构造应用程序，以解决开始使用cgo之前没有的问题。 。

哦，您必须在您的程序包支持的各种平台上调试C编译失败。

### 复杂的构建

Go的目标之一是生产一种语言，其构建过程是自我描述的；程序的源代码包含用于构建项目的工具的足够信息。这并不是说使用a `Makefile`来自动化构建工作流是不好的，但是在将cgo引入项目之前，您可能不需要任何东西，只需要`go`构建和测试工具即可。然后，要设置所有环境变量，请跟踪可能安装在怪异位置的共享库和头文件。

请记住，Go支持开箱即用的平台，因此您必须花一些时间为Windows用户提供解决方案。

哦，现在您的用户必须安装C编译器，而不仅仅是Go编译器。他们还必须安装项目所依赖的C库，因此您也将承担该支持费用。

### ~~~~交叉编译不见了

Go对交叉编译的支持是同类中最好的。从[Go 1.5开始，您可以](http://dave.cheney.net/2015/08/22/cross-compilation-with-go-1-5)使用Go项目网站上提供的官方安装程序，从任何受支持的平台[交叉编译](http://dave.cheney.net/2015/08/22/cross-compilation-with-go-1-5)到任何其他平台。

默认情况下，交叉编译时cgo是禁用的。如果您的项目是纯Go语言，通常这不是问题。当混入对C库的依赖时，要么必须放弃交叉编译产品的选项，要么必须花费时间为所有目标查找和维护交叉编译C工具链。

也许，如果您开发的产品仅通过TCP套接字与客户端通信，并且打算在SaaS模型中运行它，那么可以说您不在乎交叉编译。但是，如果您要制造一种将供他人使用的产品，并且可能集成到他们的产品中，则可能是监视解决方案，或者可能是SaaS服务的客户端，那么您就无法使用它们进行交叉编译了。

Go支持的平台数量继续增长。Go 1.5增加了对64位ARM和PowerPC的支持。Go 1.6增加了对64位MIPS的支持，IBM的s390体系结构被推崇为Go 1.7。RISC-V正在开发中。如果您的产品依赖于C库，则不仅会遇到上述交叉编译的所有问题，而且还必须确保所依赖的C代码在Go支持的新平台上可靠地工作-并且您必须C / Go混合型为您提供了有限的可调试性。这使我想到了下一个要点。



我们已经争论了一段时间，但这并没有使我们更接近解决所有问题（泄漏只是最新的问题，我们之前有很多问题）。而且，仅通过C，通过Cgo调用C ++代码的绝对丑陋（没有Cgo墙之外的任何性能分析或调试功能）就令人烦恼，以至于您怀疑只用C ++编写整个代码是否会更好。

我们选择Go over C ++是有原因的。它很干净，代码是可以理解的，非常简单，goroutines很棒。[Cgo打破goroutines 14](https://dave.cheney.net/2016/01/18/cgo-is-not-go)以及所有其他提到的好处。从历史上看，它为我们触发了深层的Cgo错误（pthread，在Go1.4中已修复，然后又在Go1.5中已修复），然后导致文件描述符问题（随着时间的推移全部修复或规避）。

https://forum.golangbridge.org/t/leveldb-written-in-go-build-from-scratch/4431/7