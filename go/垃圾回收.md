#### 垃圾回收

#### 三色垃圾算法

- 白色对象：未被回收器访问到的对象。（程序结束后为不可访问对象）（潜在的垃圾）
- 黑色对象：已被回收器访问到的对象，所有指针都被扫描，不可能指向白色。（活跃的对象）
- 灰色对象：已被回收器访问，但还没有扫描完全部指针。因为可能指向白色对象

标记-清除

- 开始时，所有对象都是白色
- 从根出发把所有可到达对象标记为灰色，放入灰色队列。
- 从灰色队列取出对象，将其子对象标记为灰色放入队列，自身标记为黑色
- 不断重复，直到灰色对象队列为空。
- 灰色为空时黑色存活而白色对象为空

![截屏2020-07-12 下午1.03.59](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-12 下午1.03.59.png)

由于在标记的过程中用户程序可能改变指针指向。

导致不该回收的被回收。

所以需要内存屏障。

- ![截屏2020-07-12 下午1.04.48](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-12 下午1.04.48.png)
- 强三色不变性：黑色对象不会指向白色对象![截屏2020-07-12 下午1.06.24](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-12 下午1.06.24.png)
- 弱三色不变性：黑色对象指向的白色对象必须可以由灰色对象可达

#### 内存屏障

#### 插入写屏障

当改变指针时，将白色的目标改变为灰色。

![截屏2020-07-12 下午1.07.52](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-12 下午1.07.52.png)

```text
writePointer(slot, ptr):
    shade(ptr)
    *slot = ptr
```

刚开始根指向a，a指向b，b指向c。

刚开始都是白色。

- a变为灰色
- a变为黑色，b变为灰色
- 改变指针，a指向c，c变为灰色
- 扫描又，b变为黑色，c变为黑色。（b没被回收）
- 如果之后a指向c重新指向b，那么c应该回收却没被回收（要等待下一轮）





实现了强三色

- 比较保守，将有存活可能的都标记为灰色。可能出现错误标记的对象要在下一轮gc才能被回收。
- 每次指针操作都会有写屏障性能开销太大；因此实际实现的时候仅会对堆上的指针插入增加写屏障；所以Go选择仅对堆上的指针插入增加写屏障，这样就会出现在扫描结束后，栈上仍存在引用白色对象的情况，这时的栈是灰色的，不满足三色不变式，所以需要对栈进行重新扫描使其变黑，完成剩余对象的标记，这个过程需要STW。（如果允许灰色存在，那么在扫描的时候又可能插入新的灰色引用；因此标记终止阶段要STW扫描栈）



#### 删除写屏障

当改变指针时，把白色的老对象变为灰色。

![截屏2020-07-12 下午1.17.16](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-12 下午1.17.16.png)

保证弱三色不变性（）



- 一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉。

#### 混合写屏障

- 因为插入写屏障会带来大量的额外开销，所以在实现上没有对栈上的对象开启，在扫描结束后会对栈上对象**重新扫描**；
- 混合写屏障虽然不存在重新扫描的需要，但是它会带来比较多的**冗余标记**操作；

结合两者可以避免栈的重扫，也可以减少一部分冗余的扫描和标记操作。



1、GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，

2、GC期间，任何创建的新对象，均为黑色。

3，被删除的对象如果是白色标记为灰色

4，被添加的对象如果是白色标记为灰色（删除写屏障）（

为了防止对于栈上的对象a，删除了指向堆上的对象c的指针（对于a无屏障）；然后对于堆上的对象b，又指向了堆上的对象c（对于b有屏障）；

那么这个时候，删除写屏障就会把b搞成灰色；当然，如果栈扫描了，那么b肯定黑色；这个时候就不用染色了；如果栈没扫描，那还是需要重新染色的。。。

）。



新创建的对象标记为黑色，因为此时没有其他人指向它，防止新分配的内存被误回收。



https://studygolang.com/articles/27243

灰色的堆对象引用白色的堆对象然后删除白色堆对象，新添加栈对象指针的引用

- 栈为黑色。无gc和屏障
- 白色的堆对象从白色变为灰色
- ![截屏2020-07-12 下午1.46.06](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-12 下午1.46.06.png)



```text
writePointer(slot, ptr):
    shade(*slot) // 删除写
    if current stack is grey:
        shade(ptr)
    *slot = ptr
```

#### 阶段分析

- 标记阶段，先暂停程序；开启写屏障，把根对象入队，用户协助程序；回复执行程序；标记进程和用于协助的用户程序会开始并发标记内存中的对象；混合写屏障把所有赋值操作的指针和新指针标记为灰色；新创建的对象直接标记为黑色

- 开始扫描根，goroutine的栈，全局对象。扫描栈时暂停处理器。

- 依次处理灰色对象，标记成黑色并将它们指向的对象也标记成灰色。

- 标记终止：暂停程序，关闭用户辅助程序

- 清理阶段：关闭写屏障，恢复用户程序，所有新对象标记为白色。

  后台并发清理内存单元。



用户辅助程序是gc时候运行的goroutine，用来帮忙的。

#### 触发gc时机

- 自动触发，两分钟没有触发就会自动触发

- 达到触发的堆大小。

  （调步算法）：一方面垃圾回收要比较早，避免结束时实际的堆大于目标堆，从而不断增加内存消耗；

  又不能太早，避免如果太早那么将会产生过量cpu消耗。

  （在runtime.gcmalloc的时候，如果当前线程的内存不够用，要从中心缓存中获取；或者32kb以上大对象时。就会使用调步算法进行检查。）

- 用户手动触发（runtime.gcStart）用户程序阻塞直到垃圾回收完成

[https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#723-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86](https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#723-实现原理)