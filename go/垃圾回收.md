#### 垃圾回收

#### 三色垃圾算法

- 白色对象：未被回收器访问到的对象。（程序结束后为不可访问对象）（潜在的垃圾）
- 黑色对象：已被回收器访问到的对象，所有指针都被扫描，不可能指向白色。（活跃的对象）
- 灰色对象：已被回收器访问，但还没有扫描完全部指针。因为可能指向白色对象

标记-清除

- 开始时，所有对象都是白色
- 从根出发把所有可到达对象标记为灰色，放入灰色队列。
- 从灰色队列取出对象，将其子对象标记为灰色放入队列，自身标记为黑色
- 不断重复，直到灰色对象队列为空。
- 灰色为空时黑色存活而白色对象就是垃圾。

![截屏2020-07-12 下午1.03.59](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-12 下午1.03.59.png)

由于在标记的过程中用户程序可能改变指针指向。

导致不该回收的被回收。

所以需要内存屏障。

- ![截屏2020-07-12 下午1.04.48](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-12 下午1.04.48.png)
- 强三色不变性：黑色对象不会指向白色对象![截屏2020-07-12 下午1.06.24](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-12 下午1.06.24.png)
- 弱三色不变性：黑色对象指向的白色对象必须可以由灰色对象可达

#### 内存屏障

#### 插入写屏障

当改变指针时，将白色的目标改变为灰色。

![截屏2020-07-12 下午1.07.52](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-12 下午1.07.52.png)

```text
writePointer(slot, ptr):
    shade(ptr)
    *slot = ptr
```

刚开始根指向a，a指向b，b指向c。

刚开始都是白色。

- a变为灰色
- a变为黑色，b变为灰色
- 改变指针，a指向c，c变为灰色
- 扫描又，b变为黑色，c变为黑色。（b没被回收）（没有被指针指向的对象）
- 如果之后a指向c重新指向b，那么c应该回收却没被回收（要等待下一轮）





实现了强三色

- 比较保守，将有存活可能的都标记为灰色。可能出现错误标记的对象要在下一轮gc才能被回收。
- 每次指针操作都会有写屏障性能开销太大；因此实际实现的时候仅会对堆上的指针插入增加写屏障；所以Go选择仅对堆上的指针插入增加写屏障，这样就会出现在扫描结束后，栈上仍存在引用白色对象的情况，这时的栈是灰色的，不满足三色不变式，所以需要对栈进行重新扫描使其变黑，完成剩余对象的标记，这个过程需要STW。（如果允许灰色存在，那么在扫描的时候又可能插入新的灰色引用；因此标记终止阶段要STW扫描栈）



#### 删除写屏障

当改变指针时，把白色的老对象变为灰色。

![截屏2020-07-12 下午1.17.16](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-12 下午1.17.16.png)

保证弱三色不变性（）



- 一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉。

#### 混合写屏障

- 因为插入写屏障会带来大量的额外开销，所以在实现上没有对栈上的对象开启，在扫描结束后会对栈上对象**重新扫描**；
- 混合写屏障虽然不存在重新扫描的需要，但是它会带来比较多的**冗余标记**操作；

结合两者可以避免栈的重扫，也可以减少一部分冗余的扫描和标记操作。



1、GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，

2、GC期间，任何创建的新对象，均为黑色。（如果堆上新创建的对象不是黑色，那么就会被立即挥手回收）

3，被删除的对象如果是白色标记为灰色

4，被添加的对象如果是白色标记为灰色（删除写屏障）（

为了防止对于栈上的对象a，删除了指向堆上的对象c的指针（对于a无屏障）；然后对于堆上的对象b，又指向了堆上的对象c（对于b有屏障）；

那么这个时候，删除写屏障就会把b搞成灰色；当然，如果栈扫描了，那么c肯定黑色；这个时候就不用染色了；如果栈没扫描，那还是需要重新染色的。。。

）。



有限实现的插入写屏障。



![截屏2020-07-16 下午8.07.47](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-16 下午8.07.47.png)



新创建的对象标记为黑色，因为此时没有其他人指向它，防止新分配的内存被误回收。



https://studygolang.com/articles/27243

灰色的堆对象引用白色的堆对象然后删除白色堆对象，新添加栈对象指针的引用

- 栈为黑色。无gc和屏障
- 白色的堆对象从白色变为灰色
- ![截屏2020-07-12 下午1.46.06](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-12 下午1.46.06.png)



```text
writePointer(slot, ptr):
    shade(*slot) // 删除写
    if current stack is grey:
        shade(ptr)
    *slot = ptr
```

#### 阶段分析

- 标记阶段，先暂停程序；开启写屏障，把根对象入队，用户协助程序；回复执行程序；标记进程和用于协助的用户程序会开始并发标记内存中的对象；混合写屏障把所有赋值操作的指针和新指针标记为灰色；新创建的对象直接标记为黑色

- 开始扫描根，goroutine的栈，全局对象。扫描栈时暂停处理器。

- 依次处理灰色对象，标记成黑色并将它们指向的对象也标记成灰色。

- 标记终止：暂停程序，关闭用户辅助程序

- 清理阶段：关闭写屏障，恢复用户程序，所有新对象标记为白色。

  后台并发清理内存单元。



用户辅助程序是gc时候运行的。



![截屏2020-07-31 下午12.51.51](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-31 下午12.51.51.png)



- Mark: 包含两部分:

- Mark Prepare: 初始化GC任务，包括开启写屏障(write barrier)和辅助GC(mutator assist)，统计root对象的任务数量等。**这个过程需要STW**
- GC Drains: 扫描所有root对象，包括全局指针和goroutine(G)栈上的指针（扫描对应G栈时需停止该G)，将其加入标记队列(灰色队列)，并循环处理灰色队列的对象，直到灰色队列为空。**该过程后台并行执行**

1. Mark Termination: 完成标记工作，重新扫描(re-scan)全局指针和栈。因为Mark和用户程序是并行的，所以在Mark过程中可能会有新的对象分配和指针赋值，这个时候就需要通过写屏障（write barrier）记录下来，re-scan 再检查一下。**这个过程也是会STW的。**
2. Sweep: 按照标记结果回收所有的白色对象，**该过程后台并行执行**
3. Sweep Termination: 对未清扫的span进行清扫, 只有上一轮的GC的清扫工作完成才可以开始新一轮的GC。 如果标记期间用户逻辑改变了刚打完标记的对象的引用状态，怎么办呢？



## . 如果内存分配速度超过了标记清除的速度怎么办？

目前的 Go 实现中，当 GC 触发后，会首先进入并发标记的阶段。并发标记会设置一个标志，并在 mallocgc 调用时进行检查。当存在新的内存分配时，会暂停分配内存过快的那些 goroutine，并将其转去执行一些辅助标记（Mark Assist）的工作，从而达到放缓继续分配、辅助 GC 的标记工作的目的。

编译器会分析用户代码，并在需要分配内存的位置，将申请内存的操作翻译为 `mallocgc` 调用，而 `mallocgc` 的实现决定了标记辅助的实现，其伪代码思路如下：


#### 根对象

1. 全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。
2. 执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上包含栈上的变量及指向分配的堆内存区块的指针。
3. 寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。

#### 触发gc时机

- 自动触发，两分钟没有触发就会自动触发

- 达到触发的堆大小。

  （调步算法）：一方面垃圾回收要比较早，避免结束时实际的堆大于目标堆，从而不断增加内存消耗；

  又不能太早，避免如果太早那么将会产生过量cpu消耗。

  （在runtime.gcmalloc的时候，如果当前线程的内存不够用，要从中心缓存中获取；或者32kb以上大对象时。就会使用调步算法进行检查。）

- 用户手动触发（runtime.gcStart）用户程序阻塞直到垃圾回收完成

[https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#723-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86](https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#723-实现原理)





![截屏2020-07-31 下午1.37.12](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-31 下午1.37.12.png)

![截屏2020-07-31 下午1.44.47](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-31 下午1.44.47.png)

![截屏2020-07-31 下午1.39.40](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-31 下午1.39.40.png)

- 目标cpu 0.25。
- 第一次触发gc为4m。
- 第一次时候的估计堆增长率为0.875

![截屏2020-07-31 下午1.51.09](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-31 下午1.51.09.png)

#### 根

根对象在垃圾回收的术语中又叫做根集合，它是垃圾回收器在标记过程时最先检查的对象，包括：

1. 全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。
2. 执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上包含栈上的变量及指向分配的堆内存区块的指针。
3. 寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。

