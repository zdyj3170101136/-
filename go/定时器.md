## 定时器

当我们创建一个定时器的时候

```
// The Timer type represents a single event.
// When the Timer expires, the current time will be sent on C,
// unless the Timer was created by AfterFunc.
// A Timer must be created with NewTimer or AfterFunc.
type Timer struct {
   C <-chan Time
   r runtimeTimer
}
```

通常返回一个只读chan。

#### 单一四叉堆

最开始的时候所有定时器都会加入一个全局四叉堆。

一个goroutine当四叉堆中定时器到期就会被唤醒

然后往chan中塞时间。



全局四叉堆公用互斥锁性能损耗

#### 分片四叉堆

go语言将全局产生64个四叉堆，每个P依据自己的pid将定时器插入对应的桶。

而每一个桶都有一个timerproc不断定期睡眠直到唤醒。

而这64个goroutine会带来巨大的开销。

#### 

最新版本，所有的timer都放在对应的P的四叉堆中。

而相比较之前的最多64个更为分配均匀。



- checkTIMER用来运行处理器中的计时器“
  - 当schedule调度

