#### 内存对齐

![截屏2020-07-16 上午10.57.36](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-16 上午10.57.36.png)

在上图中，假设从 Index 1 开始读取，将会出现很崩溃的问题。因为它的内存访问边界是不对齐的。因此 CPU 会做一些额外的处理工作。如下：

CPU 首次读取未对齐地址的第一个内存块，读取 0-3 字节。并移除不需要的字节 0
CPU 再次读取未对齐地址的第二个内存块，读取 4-7 字节。并移除不需要的字节 5、6、7 字节
合并 1-4 字节的数据
合并后放入寄存器



https://studygolang.com/articles/26701

https://blog.csdn.net/u010853261/article/details/102557188

#### 默认对齐长度



结构体的成员变量，第一个成员变量的偏移量为 0。往后的每个成员变量的对齐值必须为编译器默认对齐长度（#pragma pack(n)）或当前成员变量类型的长度（unsafe.Sizeof），取最小值作为当前类型的对齐值。其偏移量必须为对齐值的整数倍
结构体本身，对齐值必须为编译器默认对齐长度（#pragma pack(n)）或结构体的所有成员变量类型中的最大长度，取最小数的最小整数倍作为对齐值
结合以上两点，可得知若编译器默认对齐长度（#pragma pack(n)）超过结构体内成员变量的类型最大长度时，默认对齐长度是没有任何意义的

#### struct{}

零大小字段（`zero sized field`）是指`struct{}`,

大小为0，按理作为字段时不需要对齐，但当在作为结构体最后一个字段（`final field`）时需要对齐的。

为什么？

因为，如果有指针指向这个`final zero field`, 返回的地址将在结构体之外（即指向了别的内存），

如果此指针一直存活不释放对应的内存，就会有内存泄露的问题（该内存不因结构体释放而释放）

所以，Go就对这种`final zero field`也做了填充，使对齐。

#### 数组对齐

如果是一个int32位的数组，那么它的每一个数都是四字节对齐的。



首先在64位系统和32位系统上，`uint32`能保证是4bytes对齐

即`state1`地址是4N: `uintptr(unsafe.Pointer(&wg.state1))%4 == 0`

而为保证8位对齐，我们只需要判断`state1`地址是否为8的倍数

- 如果是（N为偶数），那前8bytes就是64位对齐
- 否则（N为奇数），那后8bytes是64位对齐

而且剩余的4bytes可以给`sema`字段用，也不浪费内存

![截屏2020-07-16 上午11.02.06](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-16 上午11.02.06.png)

#### 在32位平台上保证64位对齐

大致意思是，在32位系统上想要原子操作64位字（如uint64）的话，需要由调用方保证其数据地址是64位对齐的，否则原子访问会有异常。



结构体首位保证八字节对齐的。

因此我们在结构体首位放一个八字节的变量。

然后把这个结构体嵌入到其他结构体的首位。



而如果是一个64位的数实现state，一个32位数实现sema。

如果64位的数放在sema的后面。

64位数本身只能四字节对齐。

而64位数放在前面，如果结构体嵌入其他结构体不在首部，那也无法对齐。

