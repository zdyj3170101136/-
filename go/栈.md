#### 堆栈

- （1）管理方式不同。栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏；

  （2）空间大小不同。每个进程拥有的栈的大小要远远小于堆的大小。理论上，程序员可申请的堆大小为虚拟内存的大小，进程栈的大小 64bits 的 Windows 默认 1MB，64bits 的 Linux 默认 10MB；

  （3）生长方向不同。堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低。

  （4）分配方式不同。堆都是动态分配的，（运行的时候分配）没有静态分配的堆。栈是运行前自动分配。

  （5）分配效率不同。栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是由C/C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多。

  （6）存放内容不同。栈存放的内容，函数返回地址、相关参数、局部变量和寄存器内容等。当主函数调用另外一个函数的时候，要对当前函数执行断点进行保存，需要使用栈来实现，首先入栈的是主函数下一条语句的地址，即扩展指针寄存器的内容（EIP），然后是当前栈帧的底部地址，即扩展基址指针寄存器内容（EBP），再然后是被调函数的实参等，一般情况下是按照从右向左的顺序入栈，之后是被调函数的局部变量，注意静态变量是存放在数据段或者BSS段，是不入栈的。出栈的顺序正好相反，最终栈顶指向主函数下一条语句的地址，主程序又从该地址开始执行。堆，一般情况堆顶使用一个字节的空间来存放堆的大小，而堆中具体存放内容是由程序员来填充的。

  从以上可以看到，堆和栈相比，由于大量malloc()/free()或new/delete的使用，容易造成大量的内存碎片，并且可能引发用户态和核心态的切换，效率较低。栈相比于堆，在程序中应用较为广泛，最常见的是函数的调用过程由栈来实现，函数返回地址、EBP、实参和局部变量都采用栈的方式存放。虽然栈有众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，主要还是用堆。

  无论是堆还是栈，在内存使用时都要防止非法越界，越界导致的非法内存访问可能会摧毁程序的堆、栈数据，轻则导致程序运行处于不确定状态，获取不到预期结果，重则导致程序异常崩溃，这些都是我们编程时与内存打交道时应该注意的问题。
  

https://blog.csdn.net/K346K346/article/details/80849966

#### 逃逸分析

go中所有的对象，无论是否用new，make，还是字面量方法都是通过程序判断，哪些在栈上，哪些应该在对像。

- 指向栈对象的指针，不能存在于堆中
- 指向栈对象的指针不能在栈对象回收后存活

（防止栈被回收后，造成悬空指针问题）。

#### 分段栈

如果需要的栈太大，会通过链表串起来

- 热分裂问题，如果当前栈几乎满，那么任意一个函数调用都会扩容，然后运行完又会收缩。

#### 连续栈

原来的栈不够用，就申请更大的栈空间。

将旧的栈的内容复制到新的栈。将指向旧的栈的变量的指针，指向新的栈

销毁原来的栈的空间



栈每次扩容到原来的两倍，如果使用不足1 / 4就会开始缩容。



线程栈缓存，stackpool用于分配32kb以下的栈。



而大于32kb则是通过stacklarge或者堆分配。

而go的所谓的stack其实都是堆