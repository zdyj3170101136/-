#### 堆栈

- （1）管理方式不同。栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏；

  （2）空间大小不同。每个进程拥有的栈的大小要远远小于堆的大小。理论上，程序员可申请的堆大小为虚拟内存的大小，进程栈的大小 64bits 的 Windows 默认 1MB，64bits 的 Linux 默认 10MB；

  （3）生长方向不同。堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低。

  （4）分配方式不同。堆都是动态分配的，（运行的时候分配）没有静态分配的堆。栈是运行前自动分配。

  （5）分配效率不同。栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是由C/C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多。

  （6）存放内容不同。栈存放的内容，函数返回地址、相关参数、局部变量和寄存器内容等。当主函数调用另外一个函数的时候，要对当前函数执行断点进行保存，需要使用栈来实现，首先入栈的是主函数下一条语句的地址，即扩展指针寄存器的内容（EIP），然后是当前栈帧的底部地址，即扩展基址指针寄存器内容（EBP），再然后是被调函数的实参等，一般情况下是按照从右向左的顺序入栈，之后是被调函数的局部变量，注意静态变量是存放在数据段或者BSS段，是不入栈的。出栈的顺序正好相反，最终栈顶指向主函数下一条语句的地址，主程序又从该地址开始执行。堆，一般情况堆顶使用一个字节的空间来存放堆的大小，而堆中具体存放内容是由程序员来填充的。

  从以上可以看到，堆和栈相比，由于大量malloc()/free()或new/delete的使用，容易造成大量的内存碎片，并且可能引发用户态和核心态的切换，效率较低。栈相比于堆，在程序中应用较为广泛，最常见的是函数的调用过程由栈来实现，函数返回地址、EBP、实参和局部变量都采用栈的方式存放。虽然栈有众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，主要还是用堆。

  无论是堆还是栈，在内存使用时都要防止非法越界，越界导致的非法内存访问可能会摧毁程序的堆、栈数据，轻则导致程序运行处于不确定状态，获取不到预期结果，重则导致程序异常崩溃，这些都是我们编程时与内存打交道时应该注意的问题。
  

https://blog.csdn.net/K346K346/article/details/80849966

#### 逃逸分析

go中所有的对象，无论是否用new，make，还是字面量方法都是通过程序判断，哪些在栈上，哪些应该在对像。

- 指向栈对象的指针，不能存在于堆中
- 指向栈对象的指针不能在栈对象回收后存活

（防止栈被回收后，造成悬空指针问题）。

#### 分段栈

如果需要的栈太大，会通过链表串起来

- 热分裂问题，如果当前栈几乎满，那么任意一个函数调用都会扩容，然后运行完又会收缩。

#### 连续栈

原来的栈不够用，就申请更大的栈空间。

将旧的栈的内容复制到新的栈。将指向旧的栈的变量的指针，指向新的栈

销毁原来的栈的空间



栈每次扩容到原来的两倍，如果使用不足1 / 4就会开始缩容。



线程栈缓存，stackpool用于分配32kb以下的栈。



而大于32kb则是通过stacklarge或者堆分配。

而go的所谓的stack其实都是堆

#### 调用函数不同
![截屏2020-07-16 上午12.14.12](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-16 上午12.14.12.png)

先把函数

#### c函数调用过程

- 调用前，函数参数入栈，如果参数小于6个使用寄存器
- 调用的时候，将函数返回地址入栈，然后跳转到执行的函数
- 被调用的函数执行ret跳转回调用的地方（callee）
- 使用exa寄存器存储返回值
- 调用者清理栈

所以只能有一个返回值

##### go调用过程

- 先把返回值入栈，再把参数从右边到左入栈。
- 再把函数返回地址入栈
- 调用者负责返回（callee）



#### 不同

- 因此go可以有多个返回值

- 栈传递参数和值

  



- C 语言的方式能够极大地减少函数调用的额外开销，但是也增加了实现的复杂度；
  - CPU 访问栈的开销比访问寄存器高几十倍[3](https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-function-call/#fn:3)；
  - 需要单独处理函数参数过多的情况；
- Go 语言的方式能够降低实现的复杂度并支持多返回值，但是牺牲了函数调用的性能；
  - 不需要考虑超过寄存器数量的参数应该如何传递；
  - 不需要考虑不同架构上的寄存器差异；
  - 函数入参和出参的内存空间需要在栈上进行分配；



[https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-function-call/#go-%E8%AF%AD%E8%A8%80](https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-function-call/#go-语言)

https://segmentfault.com/a/1190000019753885

调用者清理

**因而可以实现可变参数的函数**。如果是被调用者负责清理的话，无法实现可变参数的函数，但是**编译代码的效率会高一点，因为清理栈的代码不用在每次调用的时候(编译器计算)生成一遍**。

从右向左入栈才能支持可变参数



如果从右向左入栈，即使参数可变。

我们知道固定参数的长度，就可以找到可变参数的位置了。



#### 闭包的变量分配在堆上



当函数引用外部作用域的变量时，我们称之为闭包。在底层实现上，闭包由函数地址和引用到的变量的地址组成，并存储在一个结构体里，在闭包被传递时，实际是该结构体的地址被传递。因为栈帧上的值在该帧的函数退出后就失效了，因此闭包引用的外部作用域的变量会被分配到堆上。在以下的实现中，test()函数返回一个闭包赋值给f，实际是main里收到闭包结构体(堆上)的地址，并保存在DX寄存器上，地址对应的内存值是闭包函数地址(函数地址取到寄存器之后，就可以通过 call 调用)，地址偏移8个字节(+8bytes)是变量x的的地址，在main里调用闭包函数f时，f内部依然是通过读取DX的值来得到变量x的地址。即**main调用f虽然没有传递参数也没有返回值，但是他们却共享了一个寄存器DX的值。**

![截屏2020-07-16 上午12.35.41](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-16 上午12.37.56.png)

#### defer

"defer 后的函数调用 在 return 语句之前执行"这句话并不容易理解正确。实际上 return xxx 语句不是原子的，而是先将xxx写入到 caller 为返回值分配的栈空间，接着执行 RET 指令这两步操作。defer函数就是插入在 RET 指令前执行。![截屏2020-07-16 上午12.42.30](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-16 上午12.42.30.png)

第一个result使用的是返回值。

而第二个不是。

第三个由于是值传递，也不是。



带返回值的return语句对应的是多条机器指令，首先是将返回值写入到caller在栈上为返回值分配的空间，然后执行ret指令。有defer语句的时候，defer语句里的函数就是插入到 ret 指令之前执行。



defer与闭包

　**defer 语句调用的函数的参数是在defer注册时求值或复制的**。因此局部变量作为参数传递给defer的函数语句后，后面对局部变量的修改将不再影响defer函数内对该变量值的使用。但是defer函数里使用非参数传入的外部函数的变量，将使用到该变量在外部函数生命周期内最终的值。

#### 栈栅和c

我们可以看出被调用的函数，有调用者的地址地址在里头。



#### go

可以看出main负责返回。

![截屏2020-07-16 上午12.46.27](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-16 上午12.49.00.png)

#### c

![截屏2020-07-16 上午12.52.43](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-16 上午12.52.43.png)

- 我们发现新的栈帧里头保存着旧的bp寄存器：栈基地址寄存器的值。
- 返回时通过拷贝旧的ebp值，重新完成跳转。
- 说明函数返回时栈还没有释放。

- 以及临时变量。



- 而函数的返回地址（下一条指令地址），在调用者那边。



我们用 `%ebp` 指向栈底，也就是基址指针；用 `%esp` 指向栈顶，也就是栈指针。下面是一个栈帧的示意图：

作者：RdouTyping
        链接：https://segmentfault.com/a/1190000007977460
        来源：SegmentFault 思否
        著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

new(T) 返回 T 的指针 *T 并指向 T 的零值。
make(T) 返回的初始化的 T，只能用于 slice，map，channel。