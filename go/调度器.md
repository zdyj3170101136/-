#### 调度器

多个线程可以属于同一个进程并共享内存空间。因为多线程不需要创建新的虚拟内存空间，所以它们也不需要内存管理单元处理上下文的切换，线程之间的通信也正是基于共享的内存进行的，与重量级的进程相比，线程显得比较轻量。



![截屏2020-07-12 下午3.52.29](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-12 下午3.52.29.png)

1. G — 表示 Goroutine，它是一个待执行的任务；
2. M — 表示操作系统的线程，它由操作系统的调度器调度和管理；
3. P — 表示处理器，它可以被看做运行在线程上的本地调度器；

#### 任务窃取

当本地满了，分一半给全局队列。

当p杯底没有的时候，随机从其他p中窃取一半。

#### 协作抢占

一个g运行10ms就会触发调度；

在函数调用前插入函数。

但是如果一致不运行函数，那么也无法执行调度。

比如一个for循环。

#### 基于信号

- 垃圾回收时挂起当前gorount
- 状态标记为可以被抢占
- 向线程发送信号
- 操作系统线程中断



| `_Gidle`      | 刚刚被分配并且还没有被初始化                                 |
| ------------- | ------------------------------------------------------------ |
| `_Grunnable`  | 没有执行代码，没有栈的所有权，存储在运行队列中               |
| `_Grunning`   | 可以执行代码，拥有栈的所有权，被赋予了内核线程 M 和处理器 P  |
| `_Gsyscall`   | 正在执行系统调用，拥有栈的所有权，没有执行用户代码，被赋予了内核线程 M 但是不在运行队列上 |
| `_Gwaiting`   | 由于运行时而被阻塞，没有执行用户代码并且不在运行队列上，但是可能存在于 Channel 的等待队列上 |
| `_Gdead`      | 没有被使用，没有执行代码，可能有分配的栈                     |
| `_Gcopystack` | 栈正在被拷贝，没有执行代码，不在运行队列上                   |
| `_Gpreempted` | 由于抢占而被阻塞，没有执行用户代码并且不在运行队列上，等待唤醒 |
| `_Gscan`      | GC 正在扫描栈空间，没有执行代码，可以与其他状态同时存在      |



也就是线程数等于 CPU 个数，在这种情况下不会触发操作系统的线程调度和上下文切换，所有的调度都会发生在用户态，由 Go 语言调度器触发，能够减少非常多的额外开销。

[https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/#%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E5%BA%A6](https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/#协作式调度)



可以看到，Go运行时存在两种类型的queue： 一种是一个全局的queue(在[schedt结构体中](https://github.com/golang/go/blob/5dd978a283ca445f8b5f255773b3904497365b61/src/runtime/runtime2.go#L536)，很少用到)， 一种是每个**P**都维护自己的**G**的queue。