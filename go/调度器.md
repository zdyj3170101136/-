#### 调度器

多个线程可以属于同一个进程并共享内存空间。因为多线程不需要创建新的虚拟内存空间，所以它们也不需要内存管理单元处理上下文的切换，线程之间的通信也正是基于共享的内存进行的，与重量级的进程相比，线程显得比较轻量。



![截屏2020-07-12 下午3.52.29](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-12 下午3.52.29.png)

1. G — 表示 Goroutine，它是一个待执行的任务；
2. M — 表示操作系统的线程，它由操作系统的调度器调度和管理；
3. P — 表示处理器，它可以被看做运行在线程上的本地调度器；

#### 任务窃取

当本地满了，分一半给全局队列。

当p杯底没有的时候，随机从其他p中窃取一半。

#### 协作抢占

一个g运行10ms就会触发调度；

在函数调用前插入函数。

但是如果一致不运行函数，那么也无法执行调度。

比如一个for循环。

#### 基于信号

- 垃圾回收时挂起当前gorount
- 状态标记为可以被抢占
- 向线程发送信号
- 操作系统线程中断



| `_Gidle`      | 刚刚被分配并且还没有被初始化                                 |
| ------------- | ------------------------------------------------------------ |
| `_Grunnable`  | 没有执行代码，没有栈的所有权，存储在运行队列中               |
| `_Grunning`   | 可以执行代码，拥有栈的所有权，被赋予了内核线程 M 和处理器 P  |
| `_Gsyscall`   | 正在执行系统调用，拥有栈的所有权，没有执行用户代码，被赋予了内核线程 M 但是不在运行队列上 |
| `_Gwaiting`   | 由于运行时而被阻塞，没有执行用户代码并且不在运行队列上，但是可能存在于 Channel 的等待队列上 |
| `_Gdead`      | 没有被使用，没有执行代码，可能有分配的栈                     |
| `_Gcopystack` | 栈正在被拷贝，没有执行代码，不在运行队列上                   |
| `_Gpreempted` | 由于抢占而被阻塞，没有执行用户代码并且不在运行队列上，等待唤醒 |
| `_Gscan`      | GC 正在扫描栈空间，没有执行代码，可以与其他状态同时存在      |



也就是线程数等于 CPU 个数，在这种情况下不会触发操作系统的线程调度和上下文切换，所有的调度都会发生在用户态，由 Go 语言调度器触发，能够减少非常多的额外开销。

[https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/#%E5%8D%8F%E4%BD%9C%E5%BC%8F%E8%B0%83%E5%BA%A6](https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/#协作式调度)



可以看到，Go运行时存在两种类型的queue： 一种是一个全局的queue(在[schedt结构体中](https://github.com/golang/go/blob/5dd978a283ca445f8b5f255773b3904497365b61/src/runtime/runtime2.go#L536)，很少用到)， 一种是每个**P**都维护自己的**G**的queue。


Runtime 负责管理任务调度，垃圾收集及运行环境。同时，Go提供了一些高级的功能，如goroutine, channel, 以及Garbage collection。这些高级功能需要一个runtime的支持. runtime和用户编译后的代码被linker静态链接起来，形成一个可执行文件。这个文件从操作系统角度来说是一个user space的独立的可执行文件。 从运行的角度来说，这个文件由2部分组成，一部分是用户的代码，另一部分就是runtime。runtime通过接口函数调用来管理goroutine, channel及其他一些高级的功能。从用户代码发起的调用操作系统API的调用都会被runtime拦截并处理。

Go runtime的一个重要的组成部分是goroutine scheduler。他负责追踪，调度每个goroutine运行，实际上是从应用程序的process所属的thread pool中分配一个thread来执行这个goroutine。因此，和java虚拟机中的Java thread和OS thread映射概念类似，每个goroutine只有分配到一个OS thread才能运行。


问题：为什么要有P？
G是对需要执行的代码逻辑的封装，M具体执行G，P存在的意义是什么？
Go语言运行时系统早期(Go1.0)的实现中并没有P的概念，Go中的调度器直接将G分配到合适的M上运行。但这样带来了很多问题，例如，不同的G在不同的M上并发运行时可能都需向系统申请资源（如堆内存），由于资源是全局的，将会由于资源竞争造成很多系统性能损耗。
Go 1.1起运行时系统加入了P，让P去管理G对象，M要想运行G必须先与一个P绑定，然后才能运行该P管理的G。P对象中预先申请一些系统资源作为本地资源，G需要的时候先向自己的P申请（无需锁保护），如果不够用或没有再向全局申请，而且从全局拿的时候会多拿一部分，以供后面高效的使用。
P的存在解耦了G和M，当M执行的G被阻塞时，P可以绑定到其他M上继续执行其管理的G，提升并发性能。

作者：Chuck_Hu
链接：https://www.jianshu.com/p/63dbec263d2a
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

https://www.pengrl.com/p/39569/

你可能会奇怪，为什么我们需要**P**，我们不能把任务队列直接挂载到线程上而去除掉**P**吗？答案是不行。原因是当运行着的线程由于某些原因需要阻塞时，我们需要通过P把任务队列挂载到其它线程中。

什么时候需要阻塞，举个例子，当我们调用系统调用的时候。因为一个线程不能一边执行代码一边阻塞在系统调用上，我们需要移交**P**使得它可以继续被调度。



#### 阻塞

![截屏2020-07-22 上午10.36.21](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-22 上午10.36.21.png)

#### 为什么用户态线程

POSIX线程API在很大程度上可以看做是对现有Unix进程模型的逻辑延伸，线程和进程有很多相似处。线程有自己的信号掩码（signal mask），可以分配与CPU关联，可以被放入cgroups，可以被查询使用了哪些资源。所有这些控制的特性都增加了开销，当你的程序中有10万个线程的时候，这些开销将会非常巨大。当不需要这些特性时，在Go语言中可以使用协程。
https://www.pengrl.com/p/39569/


另一个问题是，操作系统在Go模型下不能做出好的调度决策。举例来说，Go垃圾回收器在执行一次回收时，需要所有线程都停止，使得内存处于一致性状态。这导致需要等待所有运行着的线程到达某一个我们可以确定内存是一致的点。

当你有很多线程被调度运行在随机的点时，你必须等待它们达到一致性状态。而Go调度器可以决策出只调度到它可以确认内存是一致的点即可。这意味着当我们停下来做垃圾回收时，我们只需要等待那些正在CPU上运行的活跃的线程。

> 译者yoko注，上面这两段话有点绕，我个人的理解是，Go GC的时候需要全局内存一致性，也即全局都停下来不操作内存，Go的调度器由于系统线程数有限，更容易做到这一点。比如所有空闲系统线程不用管，所有运行时的系统线程都在执行完当前协程后暂停。这里与Go调度器做对比的应该是大量系统线程的模型，比如最土的1:1模型。



#### 调用了go之后

当我们创建一个G对象，就是 `gorutine`，它会加入到本地队列或者全局队列

如果还有空闲的P，则创建一个M 绑定该 P ，注意！这里，P 此前必须还没绑定过M 的，否则不满足空闲的条件。细节点：

1. 先找到一个空闲的P，如果没有则直接返回

2. P 个数不会占用超过自己设定的cpu个数

3. P 在被 M 绑定后，就会初始化自己的 G 队列，此时是一个`空队列`

4. 注意这里的

   ```
   一个点
   ```

   ！

   - 无论在哪个 M 中创建了一个 G，只要 P 有空闲的，就会引起新 M 的创建
   - 不需考虑当前所在 M 中所绑的 P 的 G 队列是否已满
   - 新创建的 M 所绑的 P 的初始化队列会从其他 G 队列中取任务过来

作者：林冠宏_指尖下的幽灵
链接：https://juejin.im/post/5b7678f451882533110e8948
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



#### 协助

go程序启动时会首先创建一个特殊的内核线程 `sysmon`，用来监控和管理，其内部是一个循环：

1. 记录所有 P 的 G 任务的`计数 schedtick`，schedtick会在每执行一个G任务后递增
2. 如果检查到 `schedtick` 一直没有递增，说明这个 P 一直在执行同一个 G 任务，如果超过10ms，就在这个G任务的栈信息里面加一个 tag 标记
3. 然后这个 G 任务在执行的时候，如果遇到非内联函数调用，就会检查一次这个标记，然后中断自己，把自己加到队列末尾，执行下一个G
4. 如果没有遇到`非内联函数` 调用（有时候正常的小函数会被优化成内联函数）的话，那就会一直执行这个G任务，直到它自己结束；如果是个死循环，并且 GOMAXPROCS=1 的话。那么一直只会只有一个 P 与一个 M，且队列中的其他 G 不会被执行！

例子，下面的这段代码，`hello world` 不会被输出


作者：林冠宏_指尖下的幽灵
链接：https://juejin.im/post/5b7678f451882533110e8948
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。