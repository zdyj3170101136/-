#### map

Map 通过使用hash函数对key值进行映射。使用链表法解决碰撞问题。



每一个bucket 通过八位数组保留key hash的高八位。

使用extra字段把所有的bucket串联在一起



关键是如果key和value都不是指针，那么就会把bmap标记为不含指针，这样子能够避免扫描整个hmap。

那么多余的overflow会在hmap中有个字段专门存储。



#### bucket

内部紧密存储，

先是八个key，然后是八个value；

ong1k紧密存储某些情况下就可以省略掉内存对齐字段，节省空间。

#### 装载因子

load factor表 示bucket的最大容量和实际容量比值。

6.5.

如果太小，空间利用不当。太大那么就很容易出现碰撞的情况。

#### 桶的数量

当桶的数量较小时，只会创建2  ^ B个桶。

比较大时，还会生成2 ^ B - 4个溢出桶。

溢出桶的内存和实际的bucket的内存时连续的，这样方便一点。

#### hash定位

正常hash时64位指针，最后b位bit定位桶，而高八位bit则是找出key载桶里的位置。

#### key和value

key 和 value通过大小移动位置判断。

因此实际实现，对于int64，int32这种长度确定的值，会有专门的优化。

提前按照长度走。

#### 扩容

- 装载因子超过值6.5（很bucket块要满了）
- 或者overflow的桶数量过多；当b小于15的时候，如的果overflow的桶超过2^b；当b大于16，如果overflow的数量超过2^15.
- 有些bucket被停的插入很多元素，然后又被删除，导致多空洞的ooverfl

那么就会扩容。



- 对于第一种，就是直接分配两倍的bucket数量
- 

对于第二种， 要开辟一个大小相同的新bucket空间，然后把老元素移动过去。

#### 并发搬迁

将旧bucket搬迁到新butcke

不是一下完成的，而是我们调用m[a] = key;或者delete的时候搬迁的。

首先这个函数会把当前的bucket搬走，然后顺便多搬一个



主要就是重新计算key的hash的低位，确保搬迁前后对于桶的映射不会出错。

然后如果没有协程正在使用老的bucket就把老的bucket清楚掉。

#### 随机遍历

一方面通过rehash，搬迁前后的key的位置不一样。

另一方面，当range的时候随机挑选一个bucketrange，这样能够帮助新手程序选。

#### math。NAN

这个函数的hash值每次计算都不一样。因此可以往一个map中插入任意多个math。nan。

#### tophash

对于四位的hash值的老bucket；如果新的是5。

那么通常一个会分裂为两个，一个是新，一个是旧。

#### 遍历

遍历时由于有些bucket已经到了新的地方，而有些还没有。



因此虽然遍历时在新的bucket上遍历。但对于还没有搬迁的laobucket，则需要只取出对应的部分。

https://juejin.im/post/5ce4dd5ae51d4558936a9fde#heading-0

#### 字面量

对于字面量其实会在编译期间转换为对应的代码格式。

对于map其实就是使用make（）函数，然后一步步的赋值。



