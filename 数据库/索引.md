#### 搜索码

用于在数据库中查找记录的属性我们称为搜索码。

主要有五种索引。

![截屏2020-06-18 下午4.57.24](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-06-18 下午4.57.24.png)

#### 聚集索引

聚集索引的文件物理存储顺序跟搜索码存储顺序一致。

对于INNODB，每个表都拥有一个聚集索引。

- 如果有主键，根据主键
- 如果没有主键，选择一个非空的唯一索引
- 如果这也没有，隐式的创建一个字增的列作为索引
- 因此主键越短越好
- 使用自增字段作为主键，避免b+树频繁分裂

![img](https://imgconvert.csdnimg.cn/aHR0cDovL2Jsb2cuY29kaW5nbGFicy5vcmcvdXBsb2Fkcy9waWN0dXJlcy90aGVvcnktb2YtbXlzcWwtaW5kZXgvMTEucG5n?x-oss-process=image/format,png)

整体上是一个B+树，非叶子节点存放键值，叶子结点存放完整的数据，

叶子结点通过链表索引

- 叶子节点存放完整数据，为了解决索引过大的问题。
- 刚开始时相邻叶子结点连续，随着不断的插入和删除，顺序性逐渐丢失。

[https://blog.csdn.net/u013967628/article/details/84305511#InnoDB%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0](https://blog.csdn.net/u013967628/article/details/84305511#InnoDB索引实现)

#### 辅助索引

辅助索的搜索码存的是聚集索引的键值。

- 如果存放的是实际的块的指针，由于B+树文件组织叶子结点存放实际数据，因此指针会经常更新，这个代价很高昂。
- INNODB：第一步：找到辅助索引对应的主键，通过聚集索引找到实际文件。
- 辅助索引的搜索码可以是多个

#### 联合索引

联合索引会构建多个比如col1，col2，col3；

我们会创相当于ol1,col1+col2,col1+col2+col3三种。

- 索引要保持干净，索引元素不能参与计算



#### 非聚集索引

对于MYISAM，使用b+树的非聚集索引，叶子结点存储的是实际的块的指针（磁盘号+块偏移）

![img](https://imgconvert.csdnimg.cn/aHR0cDovL2Jsb2cuY29kaW5nbGFicy5vcmcvdXBsb2Fkcy9waWN0dXJlcy90aGVvcnktb2YtbXlzcWwtaW5kZXgvOC5wbmc?x-oss-process=image/format,png)

#### B+

每个叶子结点大小为一页。则读取一个node只需要一次I/o

创建索引

` ALTER TABLE my_table ADD [UNIQUE] INDEX index_name(column_name);`

查询 Explain表示输出详细信息

` EXPLAIN SELECT * FROM employees.titles WHERE from_date='1986-06-26' AND emp_no='10001' AND title='Senior Engineer';`

每个叶子结点高度一样；

非叶子结点包含n - 1个搜索码和n个指针；

非叶子结点只存储索引信息，数据都放在叶子结点。

叶子结点间构成一个链状结构。

![img](https://img-blog.csdn.net/20180605104811583?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxOTkzNzg1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

#### B

M阶数表示最多M个子结点。

除根结点，所有非树叶结点儿子数载【n/ 2】dao1Nzhi之间。

每个内部结点包含指向N个儿子的指针，以及N - 1个数据，表示叶子结点的最小值。

所有P1指向的数据的关键字都小于P2但大于P1。

每个结点都包含数据的key和data值。

https://blog.csdn.net/qq_21993785/article/details/80576642

![img](https://img-blog.csdn.net/20180605104732528?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxOTkzNzg1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



#### 好处

- 内部结点只存储关键字，因此内部结点可以存储的关键字相同
- 所有数据查找都是从根到叶子，路径长度一样，更稳定
- 由于链饰结构，可以非常方便的进行遍历



#### 最左前缀匹配

- 对于a, b, c的前缀；只会匹配a;a, b;a, b, c
- 对于a, c；实际上是先索引查询所有的a,再通过where语句查询c，只用到了一个索引
- 如果是OR语句，则不起作用
- 对于a，c可以考虑用in来填充b

https://blog.csdn.net/u013967628/article/details/84305511#%E6%83%85%E5%86%B5%E4%B8%80%EF%BC%9A%E5%85%A8%E5%88%97%E5%8C%B9%E9%85%8D%E3%80%82](https://blog.csdn.net/u013967628/article/details/84305511#情况一：全列匹配。)

#### 覆盖索引

覆盖索引，表明辅助索引不仅仅保存聚集索引的id，而且还会保留其他值。

相比较联合索引更省空间

#### 全文索引

![截屏2020-06-18 下午5.15.40](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-06-18 下午5.15.40.png)

#### 无效

- 尽量少nullhttps://www.jianshu.com/p/3cae3e364946 https://juejin.im/post/5a4b29e8f265da43062b221b主要是因为null会多加了单位来保存数据，以及不会统计count，跟其他值相加结果还是null，null 不等于任何值，等等。（IS NULL 不会影响索引）

- LIKE中如果统配符在第一个字符，那么索引也会无效
- 不等于号
- 过多重复值，索引没啥用

#### 单列索引

对于三个单列索引

- mysql优化器如果发现一个索引就能找到，那么只会用一个索引。

  否则都可能用上

#### EXPLICIT

table | type | possible_keys | key | key_len | ref | rows | Extra

- table：从上到下

  const：表示只会读取一行， 比如说primaryKey或者用到了全部索引。

  ref：对于联合索引，如果只使用左边的前缀，则所有匹配的行将从表中读取

  range：给定范围的搜索，所有索引

  index_merge:合并索引（原本对于or这种涉及多个单一索引的字段，只会all；但现在是分别锁索引进行条件扫描，最后合并结果）

  https://www.cnblogs.com/digdeep/p/4975977.html

  index：按照索引次序扫描数据，避免排序会更快

  All：全表扫描

- key：真正使用的索引名称

- key——len：索引key的长度

- possible——keys：可能有用的有助于查询的索引

- extra：(6)Using temporary：查询需要优化了，mysql需要创建一个临时表来存储结果，这通常发生在对不同的列集进行ORDER BY上（explain select * from t1 force index(id), t2 where t1.id=1 and t1.col1 = t2.col2 order by t2.col1 ;）这个由于是在第二个部分进行order by；因此首先会把第一个表和第二个表的结果生成临时表保存。然后再排序。http://mysql.taobao.org/monthly/2015/03/04/



- (7)using where：使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户
  (4)using filesort：查询就需要优化了，mysql需要进行额外的步骤来发现如何对返回的行排序，根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行（select city,name,age from t where city='杭州' order by name limit 1000; 开始时候添加city的索引，那么order过程，则会把所有的符合city的全部取出，然后对整行进行排序，称为全字段排序；如果数据小于sort_buffer就在内存中搞，否则外部归并排序；如果大于max_length_for_sort_data那么就会只把id和name进行排序；再通过id到原来的表取出相应的字段）（如果内存够，就多利用内存，减少磁盘访问）

  Using Index:使用覆盖索引，直接从索引中获取了全部的值。

  https://www.jianshu.com/p/0d2ba78e6474



