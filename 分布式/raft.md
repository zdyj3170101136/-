#### raft

https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md

raft通过选举一个领导人，领导人管理日志的复制。数据都从领导人流向其他服务器。

Replicated And Fault Tolerant



![截屏2020-07-08 下午7.13.52](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-08 下午7.13.52.png)

所有节点都在三个状态之一：

- follower:

不会发送请求，只会响应来自leader或者candidate的请求。

不会处理client的请求，而是将请求重定向给leader



- candidate:

当foller没收到leader的心跳信息时，选举定时器就会超时，将自己的状态转换成candidtae。



- leader:当接收到客户端的写入请求，leader在本地追加一条日志；然后把这个封装成消息发送给follwer。follower发送相应。如果半数节点都发送了相应，则leader认为已经commit，给客户端返回响应。



#### 如何实现状态的切换

通过stable和raftstate两种记录。

stable是持久化的状态。raftstate是内存状态。

状态转变则通过setCurrentState先存储到持久化，再改变内存。

![截屏2020-07-08 下午8.39.40](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-08 下午8.39.40.png)

主函数不断循环，根据state运行对应的函数。

在任何一个子函数里头，只要重新调用setCurrentState函数之后，然后return。

就能够进入另一个处理逻辑。

#### term

![截屏2020-07-08 下午7.21.18](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-08 下午7.21.18.png)

term是一个全局的连续递增的整数。

当服务器之间通信的时候会交换当前任期号；

如果一个服务器的当前任期号比其他人小，那么他会更新自己的编号到较大的编号值。如果一个候选人或者领导者发现自己的任期号过期了，那么他会立即恢复成跟随者状态。如果一个节点接收到一个包含过期的任期号的请求，那么他会直接拒绝这个请求。

#### 请求投票

![](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-08 下午7.27.11.png)

- 如果对方的term比自己的小，说明是旧的；则不返回。
- 如果votefor为这个候选人的id或者为空并且候选人的日志至少和自己一样新（则用对方的term设置自己的term，转为folloewer状态（无论之前是什么状态））

#### appendentries

![截屏2020-07-08 下午8.24.09](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-08 下午8.24.09.png)

返回值包括一个lastlog，为不匹配的log的term的最早一条log，帮助跳过所有的不匹配log，加快进度。

appendentries会附带多个（最多64）。

当超时random（50 * ms）后就会认为同步没完成。



我们如图可以发现，日志索引值不变。任期号单调递增

#### follower

领导人通过heartbeatTIMEOUT（1s）（random（1 / 10）也就是0.1s到0.2s）。

毕竟要考虑到链路发送时间（但是会增加发送成本。。。）。

随机周期性的发送信息告诉跟随者自己的存在。

foller以heartbeatTIMEOUT随机化heartbeatTIMEr（1到2s）。

- 如果heartbeatTIMEr超时则检查距离上一次成功接触的时间是否超过heartbeatTIMEOUT。
  - 如果没超过恢复foller状态
  - 如果超过则把状态变为candidate，触发新一轮选举

- 拒绝其他请求，返回ErrNotleader

#### candidate

当成为candidate状态后随机化electionTimer（默认1s，随机化为一到两倍），投给自己一票，然后向其他节点发送投票请求：

- 收到Request Vote请求
  - 如果对方的term大于自己的term，则改变状态为foller，并且用对方的term设置为自己的term。
  - 如果granted已设置，表明对方投了自己一票，则总收到投票数加一；如果总收到投票数大于一半，则转变自己为foller状态。

- 当electionTimer超时则重新进入candidate状态
- reject其他的请求（返回ErrNotleader）

#### 随机选举超时时间

随机化的选举超时时间防止选举票被瓜分导致永远选不出来新的领导人。

#### 日志

leader收到客户请求

- 记录本地日志
- 向所有follower发送append entries请求
- 收到过半响应后设置为已提交，应用到自己的状态机
- 返回客户端响应
- 通知所有follwer已经commited，follwer收到后应用到本地状态机中。

每条日志包括创建时的任期号以及条目。



![截屏2020-07-08 下午8.28.43](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-08 下午8.28.43.png)

日志特性；

- 如果在不同的日志中的两个条目拥有相同的索引和任期号，那么他们存储了相同的指令。
- 如果在不同的日志中的两个条目拥有相同的索引和任期号，那么他们之前的所有日志条目也全部相同。



- 第一个特性：一个领导人只会在一个索引位置创建一个日志；并且侧位置不会改变
- 第二个特性：appendEctries附加了上条日志的索引和任期，当这个匹配时才会应用。



领导人之前的所有日志都是已commit

![截屏2020-07-08 下午9.31.31](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-08 下午9.31.31.png)

我们可以发现

- follwer可能缺少日志
- 可能会有一些未被提交的日志
- 可能两种情况都有



领导人对于每个follewer维护nextindex表示下一个要发送的日志。

初始化为自己最后一条加一。

不断减小，直到ok。

然后由规则二我们知道终究会同步



保证了

- 只要大部分机器可以工作就能正确运行
- 单个缓慢的follower不会影响整体



在 Raft 算法中，领导人处理不一致是通过强制跟随者直接复制自己的日志来解决了。这意味着在跟随者中的冲突的日志条目会被领导人的日志覆盖

#### 状态

![截屏2020-07-08 下午7.27.54](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-08 下午7.27.54.png)

记录votefor是为了向相同的request vote请求发出重复响应，防止请求丢失。

currnentTerm是用来对过期的term请求不理会，新term信息转移。

log代表日志

![截屏2020-07-08 下午9.27.32](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-08 下午9.27.32.png)

#### 安全性

日志需要给大多数人，而投票的时候也要过半。

这中间有个交集。

Raft 使用投票的方式来阻止一个候选人赢得选举除非这个候选人包含了所有已经提交的日志条目。候选人为了赢得选举必须联系集群中的大部分节点，这意味着每一个已经提交的日志条目在这些服务器节点中肯定存在于至少一个节点上。如果候选人的日志至少和大多数的服务器节点一样新（这个新的定义会在下面讨论），那么他一定持有了所有已经提交的日志条目。请求投票 RPC 实现了这样的限制：RPC 中包含了候选人的日志信息，然后投票人会拒绝掉那些日志没有自己新的投票请求。

Raft 通过比较两份日志中最后一条日志条目的索引值和任期号定义谁的日志比较新。如果两份日志最后的条目的任期号不同，那么任期号大的日志更加新。如果两份日志最后的条目任期号相同，那么日志比较长的那个就更加新。

#### 不能提前之前任期的内容

![截屏2020-07-10 下午9.22.33](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-10 下午9.22.33.png)

- (a) S1是Leader，并且部分地复制了index-2；
- (b) S1宕机，S5得到S3、S4、S5的投票当选为新的Leader（S2不会选择S5，因为S2的日志较S5新），并且在index-2写入到一个新的条目，此时是term=3（注：之所以是term=3，是因为在term-2的选举中，S3、S4、S5至少有一个参与投票，也就是至少有一个知道term-2，虽然他们没有term-2的日志）；
- (c)  S5宕机，S1恢复并被选举为Leader，并且开始继续复制日志（也就是将来自term-2的index-2复制给了S3），此时term-2，index-2已经复制给了多数的服务器，但是还没有提交；
- (d) S1再次宕机，并且S5恢复又被选举为Leader（通过S2、S3、S4投票，因为S2、S3、S4的term=4<5，且日志条目(为term=2,index=2)并没有S5的日志条目新，所以可以选举成功），然后覆盖Follower中的index-2为来自term-3的index-2；（注：此时出现了，term-2中的index-2已经复制到三台服务器，还是被覆盖掉）；
- (e) 然而，如果S1在宕机之前已经将其当前任期（term-4）的条目都复制出去，然后该条目被提交（那么S5将不能赢得选举，因为S1、S2、S3的日志term=4比S5都新）。此时所有在前的条目都会被很好地提交。

如果上述情况(c)中,term=2,index=2的日志条目被复制到大多数后，如果此时当选的S1提交了该日志条目，则后续产生的term=3，index=2会覆盖它，此时就可能会在同一个index位置先后提交一个不同的日志，这就违反了状态机安全性，产生不一致。



一个已经复制到大多数节点的日志，依然会被覆盖。



如何解决：leader可以复制前面任期的日志，但是不会提交前面任期的日志；

通过提交当前任期的日志，间接提交前面任期的日志。

https://www.cnblogs.com/gaorong/p/7274681.html

#### 安全性

t任期内提交一条日志；如果大于t的最小任期的u没有这条日志。

- u选举的时候没有那条被提交的日志，领导人不会删除
- t复制这个日志给大多数节点。同时u要求大多数节点给它投票。
- 有一个节点必定会在给u投票前收到t的复制请求，不然就会因为任期小于而被拒绝。
- 投票者在给u投票的时候必定还有这个日志（因为只有与领导人冲突的才会被删除）
- 而投票者给u投票时要求它的日志至少一样心
- 首先，如果投票者和领导人 U 的最后一条日志的任期号相同，那么领导人 U 的日志至少和投票者一样长，所以领导人 U 的日志一定包含所有投票者的日志。这是另一处矛盾，因为投票者包含了那条已经被提交的日志条目，但是在上述的假设里，领导人 U 是不包含的。
- 如果投票者和u至少一样新，那么任期号会大于，但是根据描述，我们知道不可能大于。



因此满足一致性：

果服务器已经在某个给定的索引值应用了日志条目到自己的状态机里，那么其他的服务器不会应用一个不一样的日志到同一个索引值上。

#### 其他人崩溃

简单的重新发送请求。

由于请求迷瞪，因此没问题。

#### 快照

服务器独立的创建快照将已经提交的日志。

把状态机状态保存下来。

为了日志匹配特性，同样会把前一日志条目的索引值和任期号。

一旦服务器完成一次快照，他就可以删除最后索引位置之前的所有日志和快照了。



但是领导人必须偶尔的发送快照给一些落后的跟随者。这通常发生在当领导人已经丢弃了下一条需要发送给跟随者的日志条目的时候。幸运的是这种情况不是常规操作：一个与领导人保持同步的跟随者通常都会有这个条目。然而一个运行非常缓慢的跟随者或者新加入集群的服务器（第 6 节）将不会有这个条目。这时让这个跟随者更新到最新的状态的方式就是通过网络把快照发送给他们。



这种快照的方式背离了 Raft 的强领导人原则，因为跟随者可以在不知道领导人情况下创建快照。但是我们认为这种背离是值得的。领导人的存在，是为了解决在达成一致性的时候的冲突，但是在创建快照的时候，一致性已经达成，这时不存在冲突了，所以没有领导人也是可以的。数据依然是从领导人传给跟随者，只是跟随者可以重新组织他们的数据了。



第一，发送快照会浪费网络带宽并且延缓了快照处理的时间。每个跟随者都已经拥有了所有产生快照需要的信息，而且很显然，自己从本地的状态中创建快照比通过网络接收别人发来的要经济。第二，领导人的实现会更加复杂。例如，领导人需要发送快照的同时并行的将新的日志条目发送给跟随者，这样才不会阻塞新的客户端请求。

![截屏2020-07-10 下午9.44.37](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-10 下午9.44.37.png)



#### 客户端

- 只鱼leader通信；为每一个信息附加序列号；只读操作需要最新leader。
- Raft 中的客户端发送所有请求给领导人。当客户端启动的时候，他会随机挑选一个服务器进行通信。如果客户端第一次挑选的服务器不是领导人，那么那个服务器会拒绝客户端的请求并且提供他最近接收到的领导人的信息（附加条目请求包含了领导人的网络地址）。

- 但是，如上述，Raft 是可以执行同一条命令多次的：例如，如果领导人在提交了这条日志之后，但是在响应客户端之前崩溃了，那么客户端会和新的领导人重试这条指令，导致这条命令就被再次执行了。解决方案就是客户端对于每一条指令都赋予一个唯一的序列号。然后，状态机跟踪每条指令最新的序列号和相应的响应。如果接收到一条指令，它的序列号已经被执行了，那么就立即返回结果，而不重新执行指令。

- 只读的操作可以直接处理而不需要记录日志。

因为领导人响应客户端请求时可能已经被新的领导人作废了，但是他还不知道。

Raft 中通过让领导人在响应只读请求之前，先和集群中的大多数节点交换一次心跳信息来处理这个问题。

#### 特性

- | 选举安全特性     | 对于一个给定的任期号，最多只会有一个领导人被选举出来（5.2 节） |
  | ---------------- | ------------------------------------------------------------ |
  | 领导人只附加原则 | 领导人绝对不会删除或者覆盖自己的日志，只会增加（5.3 节）     |
  | 日志匹配原则     | 如果两个日志在相同的索引位置的日志条目的任期号相同，那么我们就认为这个日志从头到这个索引位置之间全部完全相同（5.3 节） |
  | 领导人完全特性   | 如果某个日志条目在某个任期号中已经被提交，那么这个条目必然出现在更大任期号的所有领导人中（5.4 节） |
  | 状态机安全特性   | 如果一个领导人已经将给定的索引值位置的日志条目应用到状态机中，那么其他任何的服务器在这个索引位置不会应用一个不同的日志（5.4.3 节）（也就是说已经提交的日志的索引值不变） |