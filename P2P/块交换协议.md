#### 发布/订阅系统

![截屏2020-07-20 下午12.28.22](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-20 下午12.28.22.png)



- **聊天室。**每个房间都是一个发布/订阅主题，客户将聊天消息发布给房间中的所有其他客户。
- **文件共享。**每个发布/订阅主题代表一个可以下载的文件。上载器和下载器会发布它们在pub / sub主题中拥有的文件片段，并协调将在pub / sub系统之外进行的下载。



peer订阅自己感兴趣的主题，peer向所有主题订阅者广播信息。

- 所有信息传递给订阅主题的所有对等方
- 网络不会被过多的邮件副本淹没
- 对等方可以随意加入 / 离开
- 主题可以有大量的订阅用户并处理大量的信息



#### 发现

发现对等方的潜在方法包括：

- 分布式哈希表
- 本地网络广播
- 与现有对等方交换对等方列表
- 集中跟踪器或集合点
- 引导对等点列表

#### floodsub

对于每个传入的消息，转发给该主题中的所有已知对等方。由于路由器会维护先前消息的定时缓存，因此存在一些逻辑，因此不会进一步转发看到的消息。它也永远不会将消息转发回源或转发消息的对等方。

问题

- 连接大量节点的密集节点无法承受转发带宽

## gossip（闲聊网络体系架构）

#### graft和prune

#### 旧

离开主题后，对等方将通过[`PRUNE` 消息](https://github.com/libp2p/specs/blob/master/pubsub/gossipsub/gossipsub-v1.0.md#prune)通知其网格成员，并将网格从其[本地状态中](https://github.com/libp2p/specs/blob/master/pubsub/gossipsub/gossipsub-v1.0.md#router-state)删除。 作为[心跳过程的](https://github.com/libp2p/specs/blob/master/pubsub/gossipsub/gossipsub-v1.0.md#heartbeat)一部分，定期进行[进一步维护](https://github.com/libp2p/specs/blob/master/pubsub/gossipsub/gossipsub-v1.0.md#mesh-maintenance)，以在对等方来来去去时将网格大小保持在可接受的范围内。

（将peer从元数据和完整数据之间过渡）

网格链接是双向的-当一个对等方收到一条`GRAFT`消息，通知他们已将其添加到另一个对等方的网格中时，它们会依次将对等体添加到自己的网格中，前提是它们仍订阅了该主题。在稳定状态下（在[消息处理之后](https://github.com/libp2p/specs/blob/master/pubsub/gossipsub/gossipsub-v1.0.md#message-processing)），如果对等方`A`位于对等方的网格中`B`，则对等方`B`也位于对等方的网格中`A`。



#### 新

剪枝的时候，会有一段退避期。

退避期内连接将会被惩罚。（一分钟）

修剪对等体*还可以*提供一组其他对等体，修剪的对等体可以连接到该对等体以重新构造其网格

#### 仅元数据

#### 旧

还有一个网络仅仅会传递元数据。

这个表示自己最近IHVAE最近看到的信息。

对等方回复IWANT，表明自己想要的信息。





#### 新

控制八卦排放的参数称为八卦*因子*。当节点要在心跳期间发出闲话时，首先，它会选择对等方得分高于闲话阈值的所有对等方（请参见下面的[对等评分](https://github.com/libp2p/specs/blob/master/pubsub/gossipsub/gossipsub-v1.1.md#peer-scoring)）。从这些对等方中，它随机选择最小为的八卦因子对等方`D_lazy`，并将八卦发送给所选的对等方。

闲话因子的建议值为，`0.25`默认情况下，每条消息八次闲话可确保每个对等方至少有50％的机会接收有关消息的闲话。更具体地说，对于三轮八卦，对等方*未*收到有关新消息的八卦的概率为`(3/4)³=27/64=0.421875`。因此，每个对等方都有可能收到有关新消息的八卦`0.578125`。

规定了此行为以对抗sybil攻击，并确保来自诚实节点的消息以高概率在网络中传播。



#### 完整数据

#### 旧

选择4 - 12个节点传递完整数据。最好6个（仅在订阅了主题的对等方）



#### 新

选择高于一定分数的（所有）节点，不管是否有订阅这个主题进行消息转发。

确保来自诚实节点的信息一定能到达所有连接的诚实节点。



#### 对等方集合

gossippub：所有见过的peer。

mesh：表示订阅了该主题的节点。

通过心跳机制，在mesh和possip里头迁移。

```
for each topic in mesh:
 if |mesh[topic]| < D_low:
   select D - |mesh[topic]| peers from peers.gossipsub[topic] - mesh[topic]
    ; i.e. not including those peers that are already in the topic mesh.
   for each new peer:
     add peer to mesh[topic]
     emit GRAFT(topic) control message to peer

 if |mesh[topic]| > D_high:
   select |mesh[topic]| - D peers from mesh[topic]
   for each new peer:
     remove peer from mesh[topic]
     emit PRUNE(topic) control message to peer
```

fanout：表示没有订阅该主题的节点。

其中fanout是能够向未订阅的主题快速传送消息（因为我们可能不想收到消息）

2min后没发送消息，就会被遗忘

![截屏2020-07-20 下午1.42.42](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-20 下午1.42.42.png)

![截屏2020-07-20 下午1.39.50](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-20 下午1.39.50.png)

#### 缓存

#### 旧

维护seen缓存和mcache缓存。

#### mcache

mcache以每一个心跳（也就是1s将消息划分成窗口间隔）。

当发送八卦信息时，发送mcache_gossip条历史窗口的信息。



![截屏2020-07-20 下午1.16.00](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-20 下午1.16.00.png)



seen消息：缓存最近两分钟内自己看到的消息（避免重复发送）

- 路由器收到[`IHAVE(ids)`消息后](https://github.com/libp2p/specs/blob/master/pubsub/gossipsub/gossipsub-v1.0.md#ihave)，将检查其 `seen`缓存。如果该`IHAVE`消息包含未看到的消息ID，则路由器将向他们请求一条`IWANT`消息。
- 路由器收到[`IWANT(ids)`消息后](https://github.com/libp2p/specs/blob/master/pubsub/gossipsub/gossipsub-v1.0.md#iwant)，将对其进行检查 [`mcache`](https://github.com/libp2p/specs/blob/master/pubsub/gossipsub/gossipsub-v1.0.md#message-cache)，并将转发`mcache`给该`IWANT`消息的对等方转发请求中存在的所有请求消息。

#### 分数

通过以下7个标准统计分数。

该分数由每个单独的对等方根据观察到的行为本地计算，并且不会共享。

分数是通过加权混合计算所有（已配置）主题的分数，因此一个主题中的错误行为会渗入其他主题。此外，分数会在对等方断开连接后保留一段时间，因此恶意对等方在下降到负数时无法轻易重置其分数，并且行为良好的对等方不会因为断开而失去状态。



对等方保留`D_score`得分最高的对等方，并选择其余对等方以随机方式进行。这样可以保护网格免受接管攻击，并确保得分最高的对等方保留在网格中。



通过计算分数，确定消息传播度。通过分数主要限制消息的gossip以及发布。

- `0`：基线阈值；得分低于此阈值的对等体在心跳期间从网格中删除，在寻找要移植的对等体时被忽略。此外，不会向这些对等方发出PX信息，并且会忽略它们。另外，在执行PX时，仅交换分数为非负值的对等体。
- `gossipThreshold`：当一个对等方的分数下降到此阈值以下时，不会向该对等方发出闲话，并且忽略该对等方的闲话。此阈值应为负，以便可以向得分较低的对等体传播某些信息。
- `publishThreshold`：当对等方的得分下降到此阈值以下时，（洪泛）发布时，自发布消息不会向该对等方传播。此阈值应为负，并且小于或等于八卦阈值。
- `graylistThreshold`：当一个对等方的得分下降到此阈值以下时，该对等方被列入灰名单，并且其RPC被忽略。此阈值必须为负，并且小于八卦/发布阈值。
- `acceptPXThreshold`：当对等方通过修剪将PX信息发送给我们时，如果原始对等方的分数超过此阈值，则我们仅接受该信息并连接到提供的对等方。此阈值应为非负值，并且为了提高安全性，只有引导程序和其他受信任的良好连接的对等方才能获得较大的正分数。
- `opportunisticGraftThreshold`：当网格中的对等体分数中值下降到该值以下时，路由器可能会选择得分高于中位数的更多对等体，以机会性地嫁接到网格上（请参阅下面的机会性嫁接）。该阈值应为正，与通过主题贡献可获得的分数相比，其值应相对较小。



计数器会定期*衰减，*以使它们的值不会持续增加，并确保对等端的整个生命周期内不会出现较大的正负得分。

- `P₁`：**时间网**的话题。这是对等点进入网格的时间，上限设置为一个较小的值并与较小的正权重混合。这旨在增强已经在网格中的对等端，从而不会由于超额订阅而过早地修剪它们。
- `P₂`：主题的**首次邮件传递**。这是主题中对等体首先传递的消息数，并带有正权重。这旨在奖励首先转发有效消息的同伴。
- `P₃`：主题的**网格消息传递速率**。此参数是主题中网格内预期消息传递速率的阈值。如果交货数量高于阈值，则该值为0。如果数量低于阈值，则该参数的值为亏损的平方。这是为了惩罚未传递预期数量的消息的网格中的对等点，以便可以将它们从网格中删除。参数与负权重混合。
- `P₃b`：主题的**网格消息传递失败**。这是一个粘性参数，用于计算网格消息传递失败的次数。每当对等点被修剪为负分数时，该参数会因修剪时的速率不足而增加。这是为了保留修剪的历史记录，以使由于交付不足而被修剪的同伴不能迅速地重新植入网格中。参数与负权重混合。
- `P₄`：主题的**无效消息**。这是主题中传递的无效消息的数量。这旨在根据应用程序特定的验证规则对发送无效消息的对等节点进行惩罚。它与负重量混合在一起。
- `P₅`：**应用程序特定**分数。这是应用程序自身使用特定于应用程序的规则分配给对等方的分数组件。权重为正，但是参数本身具有任意实数值，因此应用程序可以在完成特定于应用程序的握手之前用负的分数来发信号表示不当行为或对等。
- `P₆`：**IP共置因子**。该参数是使用相同IP地址的对等体数量的阈值。如果同一IP中的对等方数目超过阈值，则该值为剩余的平方，否则为0。这旨在通过使用少量IP使其难以进行sybil攻击。参数与负权重混合。
- `P₇`：**行为处罚**。此参数捕获对不当行为施加的惩罚。该参数具有关联的（递减）计数器，路由器在特定事件下会明确地增加该计数器。参数的值是计数器的平方，并与负权重混合。（剪枝的回避期）

#### 机会嫁接

- 路由器可能因性能不佳的客户流失或成功的大规模冷启动或隐蔽闪存攻击而陷入性能不佳的客户网络中。发生这种情况时，路由器通常会通过网状网络故障惩罚做出反应（请参阅下面的“评分功能”），但是此反应时间可能会很慢：在非负得分点之间会随机选择替换负得分点的对等点，这可能会导致西比尔毒死池中进行多轮选择。此外，西比尔的数量可能如此之大，以至于在选择任何同伴之前，粘性网格破坏的惩罚会完全消失，从而使西比尔重新符合嫁接的条件。

  为了从此类灾难情形中恢复并随着时间的推移通常自适应地优化网格，gossipsub v1.1引入了机会移植机制。路由器会定期检查网格中对等点的中位数`opportunisticGrafThreshold`。如果中位数得分低于阈值，则路由器会机会性地（至少）移植两个得分高于网格中位数的对等节点。通过引入可能一直困扰我们的得分高的同伴，可以改善表现欠佳的网格。这也允许路由器通过使用最近已实际通过八卦转发消息的对等节点替换尝试进行月食的sybil来摆脱粘性灾难情况。

  建议的机会移植时间为1分钟，而路由器应移植2个对等节点（具有默认参数），以便它有机会成为它们之间的管道并在网格中建立分数。尽管如此，机会嫁接的对等体的数量仍由应用程序控制。如果应用程序配置的网格大于默认参数，则可能需要嫁接更多的对等节点。



#### 对应垃圾邮件

为了抵制引起响应并消耗资源的垃圾邮件，已采取了一些措施：

- `GRAFT`未知主题的消息将被忽略；在gossipsub v1.0中，路由器始终会以进行响应`PRUNE`，从而为垃圾`GRAFT`邮件泛滥和消耗资源开辟了一条途径。
- `IWANT`消息响应在到特定对等方的重传次数上受到限制；在gossipsub v1.0中，`IWANT`当邮件在缓存中时，路由器总是响应邮件。在gossipsub v1.1中，路由器对每个对等方响应的次数有限，因此`IWANT`垃圾邮件不会导致大量资源浪费。
- `IHAVE`消息的上限是一定数量的`IHAVE`消息，如果`IHAVE`收到的广告超过限制（或者，发布的消息超过限制），则将`IHAVE` 忽略其他消息。
- 在飞行中`IWANT`，作为对`IHAVE`广告的响应而发送的请求被概率跟踪。对于每个`IHAVE`引发`IWANT`请求的广告，路由器都会跟踪广告集中的随机消息ID。如果在一段时间内未收到消息（从任何对等方收到），则通过将行为惩罚应用于广告对等方`P₇`。此措施可`IHAVE`通过快速标记和伪造通告伪造的消息ID和/或不跟进`IWANT`请求的对等方并将其列入灰名单，从而防止垃圾邮件泛滥。
- `IHAVE`评分功能会对直接发送或作为对邮件的响应的无效邮件垃圾邮件进行惩罚。传输大量垃圾邮件的同伴将很快进入灰名单，从而减少了垃圾邮件引发的计算（例如验证）的范围。如果垃圾邮件在负分数下降之后仍然持续存在，则应用程序可以采取进一步的步骤并将对等方列入黑名单。

强烈建议通过配置了Peer Exchange和较高应用程序特定评分的引导程序/目录节点来增强任何外部发现服务，如上所述。

#### kademlia（分布式hash表）

用于做内容发现的。



*Keys* 是不透明的、 *160* 位长的数（比如：某些大数据的 *SHA-1 hash* 值）。参与其中的计算机都具有一个节点 *ID* ，位于这 *160* 位 *key* 空间之中。根据某种对“接近”的定义， * ， *value>* 对被存储在 *ID* 和 *key* “接近”的节点之上。

每个key都会放在鱼id值最接近的节点。



*XOR* 是对称的，因此 *Kademlia* 节点所接收到的 *lookup* 查询请求的发送者就具有和其路由表中的节点完全一样的分布。



其中每个节点的位置由其 *ID* 的最短唯一前缀决定。图 *1* 展示了一棵示例树中唯一前缀为 *0011* 的节



通过异或操作。（所有位相同的最小，并且不相同的位最低的最小）



- 路由表由队列组成，ip地址，udp port，nodeID三个。
- kad根据距离生成160个bucket
- 每个bucket放八个节点



- 如果发送节点已经存在于接收节点的 *k-bucket* 中，接收节点就会把其移到列表的尾部。如果发送节点还没有出现在相应的 *k-bucket* 中，并且该 *k-bucket* 中的元素个数小于 *k*，那么接收节点就把发送着放到列表的尾部。如果相应的 *k-bucket* 中的元素达到上限，此时，接收节点会 *ping* 该 *k-bucekt* 中最近最少联系的节点来决定该如何做。如果最近最少联系的节点没有响应，那么就把其从 *k-bucket* 中去除，然后把发送节点插入列表尾部。否则，如果收到了最近最少联系的节点的响应，那么就把其移到列表尾部，并丢弃掉发送者节点的联系信息。（通过保留那些最老的、活动的联系信息，*k-bucekts* 最大化了其所保存的节点依然在线的可能性。）

攻击者无法通过向系统中洪泛新节点的方法清空节点的路由状态。 *Kademlia* 节点只会在老节点离开系统时才插入新的节点。







#### 查询

如果要查找id值为t的节点，就计算自己到t的距离。

然后根据距离找到对应的bucket。

于所有的 *RPCs* ，接收者必须在回应中复制一个 *160* 位的随机 *RPC ID* ，这可以阻止一些地址欺骗行为。 *RPC* 的接收者可以把 *PING* 附带在 *RPC* 的回应中以进一步确认发送者网络地址的有效性。

 

​    *Kademlia* 节点必须要做的最重要的事情是找出距离某个给定节点 *ID* 最近的 *k* 个节点。我们把这个过程叫做节点查询。 *Kademlia* 采用了一个递归算法进行节点查询。查询的发起者首先从最近的非空 *k-bucket* 中选出 *a* 个节点（如果该 *bucket* 中元素的个数小于 *a* ，那么就选出它所知道的 *a* 个最近的节点）。接着，发起者向选出的这 *a* 个节点同时发送异步的 *FIND_NODE RPC* 。 *a* 是一个系统范围内的并发参数，比如， *3* 。



然后对应的节点也取出自己距离最近的3个节点后返回。

查询发起者 ![[公式]](https://www.zhihu.com/equation?tex=L) 收到响应后，会将被这些作为接下来的查询对象继续进行查询。查询收到响应时，会对响应中的结果进行过滤：如果该节点在之前已经被询问过，便不再加入待查询列表，保证查询的收敛性。



确保收敛速度为O（logN）

值会缓存在key-value节点（过期时间鱼距离成反比）

防止过热，和过冷

##### 加入

*u* 把 *w* 插入到相应的 *k-bucket* 中。接着， *u* 发起一次针对自己节点 *ID* 的查询。最后， *u* 更新比最近相邻节点远的所有 *k-buckets* 。在更新过程中， *u* 既填充了自己的 *k-buckets* ，同时也把自己加入到其他节点的 *k-buckets* 中。



通过上面的重复步骤，新增节点逐步建立起对网络节点的理解，而且，通过该机制可以了解到，新增节点会更多地发现距离自己更接近的节点信息。



如果k桶满了，且覆盖了当前节点的id信息；则分裂为两个；

否则忽略。

#### push

Push：如果新增一个节点 ![[公式]](https://www.zhihu.com/equation?tex=N) ，且距离某对象 ![[公式]](https://www.zhihu.com/equation?tex=O) 的更为接近，一旦对象所在的节点探测到 ![[公式]](https://www.zhihu.com/equation?tex=N) 的存在，会主动地将数据推至 ![[公式]](https://www.zhihu.com/equation?tex=N) ，这也可以保证下次访问时无需中转而直接获取到数据。



在论文中，作者提出了按照小时为单位执行Re-Publishing：每个小时，每个节点对本地存储的每一个对象进行Re-Publishing。每一次Re-Publishing包括下面两个步骤:

1. 首先查询当前最近的K个节点信息；
2. 节点向1中获得的节点发送数据存储消息，从而完成数据更新

针对每个节点的每个对象都执行类似操作，会导致P2P网络出现突激的网络流量。仔细分析上面的行为，我们可以发现，其实很多的Re-Publishing是无用的：

> 如果在一个小时的周期内，网络拓扑没有发生变化，那根本不需要进行Re-Publishing；
>
> 对于不同的节点、，如果对象在节点、上均已存储，那其实在一个Re-Publishing周期内，只需要一个节点(或者)来更新即可，没必要大家同时一起上，浪费资源；
>
> 步骤1中的K-Closest查询是否有必要：因为根据上面的表述，对于新增节点，其实是可以很快速地反映到最近节点路由表，所以一般情况下，查询本地节点路由表即可。

针对上面的疑问，论文中也提出了几点优化方案：

- 避免不必要的Re-Publishing：首先，如果对象刚被写入（Re-Publishing周期内写入的），那么认为该对象其实是被写到最新的网络拓扑节点中，那就不对该对象做Re-Publishing；
- 关于多节点同时Re-Publishing相同对象问题，可以这么解：将不同节点的Re-Publishing设置不一样（如在一个范围内随机取值），这样，例如节点 Re-Publishing了对象，节点再次Re-Publishing对象时便发现其最后修改时间是刚刚，根据上面的描述，节点就不再Re-Publishing了，存储的其他节点同样如此，有效避免了一个周期内多节点同时Re-Publishing问题；
- 关于避免节点更新问题，大家自行参考论文吧，懒得看了。



客户流失攻击：如果攻击者拥有一些节点，他可能会在网络中引发高流失，直到网络稳定失败。 由于建议Kademlia节点在其路由表中保留长期联系人，因此这种攻击对Kademlia覆盖拓扑没有太大影响。

 

敌对路由：当路由表既不响应路由信息也不路由任何分组时，简单地从路由表中删除节点，影响网络路由的唯一方式是返回敌对路由信息。 例如，敌对节点可能只是返回更接近查询Key的其他协作节点。 这样一种敌对节点将数据包路由到其协作者的子网中，并且查找到的和给定Key的最近节点都不会被找到。 这可以通过使用考虑多个不相交路径的查找算法来防止。 当一条路径没有敌对节点时，查找成功。 因此，假设m是对抗节点的分数，d是不相交路径的数量，（hi）路径长度分布，则查找成功的概率由下式给出
————————————————
版权声明：本文为CSDN博主「Omnigeeker1111」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/elninowang/java/article/details/80599908



#### 安全节点

为了让节点不能自由选择其id，要生成一个公钥，这个公钥两次hash运算后有c1个前导0，那么一次hash运算的值就是nodeid；

不断生成一个随机数，要让随机数与nodeid求异或操作后再求hash有c2个前导0。

随机数，增加难度。使得女巫做法不可取。因为大量生成id很困难。

静态的不能随意选择id，防止日蚀攻击。



确保身份不能被窃取，使用私密钥匙验证数据和发型。



#### 强签名和弱签名

弱签名：弱签名不签署整个消息。 它仅限于IP地址，端口和时间戳。 时间戳指定签名有效的时间。 如果使用动态IP地址，这将防止重放攻击。 对于同步问题，时间戳可能以非常粗糙的方式选择。 弱签名主要用于FIND NODE和PING消息，其中整个消息的完整性是可有可无的。

 

• 强有力的签名：强有力的签名在邮件的全部内容上签名。 这确保了消息的完整性和抵御中间人攻击的弹性。RPC消息内的随机数可以防止重放攻击。
————————————————
版权声明：本文为CSDN博主「Omnigeeker1111」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/elninowang/java/article/details/80599908

#### 不相交路径查找

- 为了避免恶意节点不断转发信息，而不回答。
- 每次查询选择d个不相交的桶并发查询





#### bittorrent

用户同时上传和下载数据，更快。

seed生成。torrent文件（保存文件名，大小，tracker的url）

tracker：保存文件信息和seek的连接信息。



通过.torrent文件访问seek

- 通过dht知道哪些节点有快
- 优先完成单一片段，
- 尽量从相同的peer请求一个piece的数据（愿意发送一个就愿意发送更多）
- 优先序赞额稀缺片段（越稀少者越优先）
- 最少的片段下载慢，因此第一个片段随机选择



- 如果从一个节点速率很低，那么我的速率也很低（一报还一报）
- 完成下载后还提供上传服务一段时间
- 随机30s不阻塞一个节点的下载速度一个节点不管它的之前的速率如何（乐观不阻塞）
- 阻塞算法，每10s计算一次速率，只跟4个peer连接d
- 256kb大小的块



阻塞策略：拒绝上传，继续下载。

- 反对歧视，如果自己一直没有从节点收到块，则认为自己被block了，因此也不再提供上传。
- 下载结束后，不通过下载速率进行判断；选择上传速率最快的节点，充分利用上传带宽。

- 信用策略
- 计算节点收到数据和发送数据的比率计算信用分。（sent / recv + 1）
- 通过这个计算发送概率，信用分越大发送概率越小
- 通过节点之间交换账单信息；如果总是有节点账单不匹配丢失则为恶意节点，不进行发送。
- 