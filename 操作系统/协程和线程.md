#### 协程和线程

- 协程栈大小小，只有几kb；线程栈通常为10 m左右
- 协程切换在用户态，线程切换需要在内核态。
- 线程和协程的资源不同，线程包括cpu资源，io资源，定时器资源。
- go创建数量等于操作系统核心数量的线程，让它们一直运行，减少切换损耗；而协程就竞争线程。
- 不同进程切换需要刷新TLB，系统缺页中断开销
- 线程切换使用相同的task struct，开销更小。





进程是操作系统分配资源的一个单位。

而线程共享该进程的资源，只是每个线程有自己的栈。

#### 进程

![截屏2020-07-10 下午1.19.46](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-10 下午1.19.46.png)

running：正在cpu上运行或者在就绪队列等待调度，可以运行。

uninterrupidtible sleep（不可中断睡眠）D：不可通过发送信号唤醒，kill无法杀死。（如果响应异步信号，程序的执行流程中就会被插入一段用于处理异步信号的流程（这个插入的流程可能只存在于内核态，也可能延伸到用户态），于是原有的流程就被中断了。（参见《linux内核异步中断浅析》）在进程对某些硬件进行操作时（比如进程调用read系统调用对某个设备文件进行读操作，而read系统调用最终执行到对应设备驱动的代码，并与对应的物理设备进行交互），可能需要使用TASK_UNINTERRUPTIBLE状态对进程进行保护，以避免进程与设备交互的过程被打断，造成设备陷入不可控的状态。）

interruptiable sleep（可中断睡眠）S：可以通过发送信号唤醒。

stop（暂停状态）（T）：SIGSTOP信号。SIGCONT恢复运行。

Z（僵尸状态）：子进程资源多数已经被回收，除了pcb。向父亲发送SIGCHLD让父亲来回收（如果父进程也死了，就会被init也就是1号进程周期性回收。）

https://www.cnblogs.com/YDDMAX/p/4979878.html

#### 三大基础状态

就绪，执行，阻塞。

![截屏2020-07-10 下午2.25.10](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-10 下午2.25.10.png)

#### 进程地址空间

![截屏2020-07-10 下午1.38.41](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-10 下午1.38.41.png)

进程从下到上分为

- text代码段：存放只读的执行cpu的可执行文件的指令，包括一些字符串常量（可共享，对于频繁被执行的程序，只需要一份拷贝）
- 存放 CPU 可以执行的机器指令，该部分内存只能读不能写。通常代码区是共享的，即其它执行程序可调用它。假如机器中有数个进程运行相同的一个程序，那么它们就可以使用同一个代码段。
- bss段：存储未初始化的全局变量，静态变量，不分配空间（只是记录数据所需空间）BSS 的数据在程序开始执行之前被初始化为 0 或 NULL。
- date段：经过初始化的全局和静态变量。

（因此同样的程序，date的可执行文件会比较大）

- 堆：从下到上增长，运行时动态分配的内存。

- mmap区域：使磁盘文件与存储空间执行的一个映射。（这样读取就能直接把文件读到进程空间）（而相对于传统的write/read　IO系统调用, 必须先把数据从磁盘拷贝至到**内核缓冲区中(页缓冲)**，然后再把数据拷贝至用户进程中。两者相比，**mmap会少一次拷贝数据**，这样带来的性能提升是巨大的。）

  （通过引发缺页异常，实现文件内容到物理内存的拷贝）

  https://blog.csdn.net/Holy_666/article/details/86532671

- 栈：存放局部变量，从高地址向低地址增长；存放函数调用信息和返回地址。

https://zhuanlan.zhihu.com/p/28659560

#### 进程和线程

进程是操作系统资源分配的单位，而线程是cpu运行的单位。

线程共享

- 进程代码段
- 数据段
- 打开的文件
- 堆

独立

- 线程id (查询使用了哪些资源)
- signalmask
- 程序计数器（用来保存状态）
- 寄存器
- 优先级（能够独立调度）
- 栈

https://blog.csdn.net/WangQYoho/article/details/52598859

#### 好处

- 线程资源少，切换上下文比进程快
- 多线程共享程序文件，执行效率高



#### 内核和用户线程



现在操作系统的线程实现模型：

鉴于用户态与内核态都存在缺陷，现代操作将两者结合起来。用户态的执行负责进程内部线程在非阻塞时的切换；内核态的操作系

统负责阻塞线程的切换，即我们同时实现内核态和用户态线程管理。每个内核态线程可以服务一个或者更多个用户态线程。



线程从用户态切换到内核态：

什么情况下会造成线程从用户态到内核态的切换呢？

首先，如果在程序运行过程中发生中断或者异常，系统将自动切换到内核态来运行中断或异常处理机制。

此外，程序进行系统调用也会从用户态切换到内核态。
————————————————
版权声明：本文为CSDN博主「Wangqyoho」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/WangQYoho/java/article/details/52598859

因为多线程不需要创建新的虚拟内存空间，所以它们也不需要内存管理单元处理上下文的切换，线程之间的通信也正是基于共享的内存进行的，与重量级的进程相比，线程显得比较轻量。

#### 多进程优点

多进程互相独立，即使一个崩溃也不会影响其他。

减少线程加锁的损耗。

切换和创建复杂。

进程通信复杂，需要ipc， 共享复杂同步简单；线程共享数据，需要同步/

https://zhuanlan.zhihu.com/p/45233772



在自动驾驶操作系统使用多进程，（容错更高）

（linux中进程和线程主要在于通信之间的麻烦程度）

![截屏2020-07-10 下午2.49.20](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-10 下午2.49.20.png)

#### 多线程

![截屏2020-07-22 下午9.41.16](/Users/jieyang/Library/Application Support/typora-user-images/截屏2020-07-22 下午9.41.16.png)

