#### CPU调度

传统调度器通过分配静态有限级获得更大的连续执行时间。

麻烦在于处理用户交互的进程。

用户交互进程要求低延时，因此我们通过分配高优先级获得良好用户体验。

但是分配大时间片没有意思，因为这种进程是处于阻塞态，等待用户输入。

但是后台进程优先级不高，最好趁着cache hot狂奔/



#### 

cfs调度器的话，就是每个cpu上都有一个cpu runqueue。

以及每个进程都有一个调度类，cpu呢就先运行高级别的调度器。

- deadline

- rr

- cfs

- idle

  

#### CFS

cpu运算资源公平分配。

传统的可能是一个进程连续运行完自己的分配的固定的时间片后就会被挂起来。

但是cfs做到在一个更细的粒度公平分配时间。

这中间可能进程之间互相切换了很多次。

不过实际上为了避免频繁切换，会有一个调度周期的概念。

#### 调度周期

少于就绪态的进程少于8个的话，就是6ms。超过8个就是8*0.75ms。

就是每个进程至少运行一次cpu0.75ms的时间。



vruntime大于1ms，才会抢占，避免频繁的抢占。

#### vruntime

vruntime = runtime （weight / 总weitht * 时间） * 1024 / weight

为了精度问题，会vruntime = vruntime *  2 ^ 32/ 2 ^32。



如果一个进程执行，那么其vruntime增大，不执行的不变，我们就选择红黑树上最小的执行。

因此，优先级高的进程增长的慢，获得更多运行时间。



由于红黑树，需要一个比较时间。

#### nice

weight根据nice值计算，weight = 1024 / 1.25 ^nice。

没降低一个nice，对其他进程增加10%的运行时间，表示对其他进程的友好值。

#### 优化

- 新创建的进程增加一个值，防止新创建进程疯狂追赶
- sleep的进程被wake up减少一个minruntime，当作奖励。

（交互式进程）

- min——runtime是一个动态的值，不同的cpu上的min——runtime不同。
- 子进程的要比父进程的vruntime小，确保子进程比父的先运行

#### 功耗计算

- 所有runnable状态的进程，不在cpu上运行的进程也有功耗
- 阻塞进程也有功耗，比如因为page fault而阻塞

#### 实时进程

实时进程当事件发生后必须在规定时间范围内响应。

- DL：
- RT：FIFO和RR

对于FIFO，最先进入runnable的状态通过静态优先级获取cpu资源，一直占用率。

而对于RR调度器，有时间片的概念，进程时间片用完放到对应优先级的链表中取去。



DEADLINE：deadline调度器就是按照进程截止时间排序，调度它运行。

period（每多少s必须运行一次的时间）

runtime（运行时间）

deadline（最后截止时间）



可以确保，每一个perod都会分配runtime运行时间，而且在deadline之前。



- 会拒绝无法完成的deadline

  https://cloud.tencent.com/developer/article/1448416