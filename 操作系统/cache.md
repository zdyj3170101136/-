#### powerpc风格的

首先我们使用move操作用三个寄存器保存值。



原子指令：以x开头或者加上lock为前缀的。

原子指令：

- 一致性协议要使得其他cpu上的cache置为无效，获得独家访问权。
- 完成原子指令前防止当前块被偷走（基于总线的处理其中，就是预约总线直到指令完成）



一个test- and-set锁：

lock：

首先通过原子性的独占读操作读取lockvar的值（引起busrdx总线事务，使得其他高速缓存块状态失效，修改自己告诉缓存块状态为M）

如果lockvar不为1就用bnz操作跳回lock。

不然就return表示获取了锁



unlock：

把lockvar置为0，也不需要原子性指令，因为只有一个在临界区。



缺点：

每一次获取锁的操作都会出发一个总线事务。

通信量太大了。



#### test and test and set锁

lock：

ld非原子的读取指令加载lockvar。

直到lockvar为1的时候我们才原子的去加载这个值。



但是啊，原子性的指令本身实现起来代价很大。

从其他处理器的角度来说，其实只有unlock的加载指令是可见的。

而其他指令，加载和分支对它们没啥影响。



如果加载和存储指令中间发生的一些事未被原子性现象。那么存储将失败。

- 一个上下文切换或者中断发生在这中间
- 加载的块在存储指令执行前就被无效化了。



LL / SC锁。

LL不仅加载一个块，而且还把块的地址保存在链接寄存器中。

SC指令是特殊的存储指令，只有在它涉及的块的地址和链接寄存器相同的时候才ok



- 链接寄存器啊就是当发生上下文中断或者高速缓存无效才会被清空。



实践中还需要有lwsync，栅栏指令。

lwsync是常规栅栏，阻止向前向后。

阻止向前指的是，这条指令之后的指令不能在lwsync之前执行。

阻止向后指的是，这条指令之前的指令不能在lwsync之后执行。



#### 为什么

因为编译器会调换指令之间的执行顺序。



比如说一个load和一个store



store指令首先要讲指令写入写缓冲区，然后无效其他处理器上的值。

load指令就是从高速缓存中获取值。





放松了store-》load的次序要求

（当一条store指令还未执行前，能让晚的load直接向高速缓存加载请求）。

（降低了load指令的时延迟）。

（只有想x86，amd可以）。



https://www.jianshu.com/p/64240319ed60

#### mesi

m表示缓存块有效并且与主存不同；

e表示缓存块是有效且唯一的。

s表示缓存块干净但在多个处理器中有

i表示缓存块无效。



一个对e状态的写操作不需要访问总线。因为是系统中唯一的。

（不然每次的写入都要将其他处理器上的块变成s状态）。



- 通过写无效其他缓存处理器上的，其他缓存将会因为缺失而重新加载
- 通过侦听总线请求把m块发出去，让其他处理器能获取最新值。





#### power7

l1高速缓存分为两个部分（数据和指令）（数据的cache通常是指令cache两倍大小）

大小32kb。三个bank口。一个时钟周期两个读一个写。

八路相联。块大小128b。

写直达。

写直达的话，修改立即传播到外围存储。

但是这样会浪费缓存。



cache可能会遇到错误，就是一个1翻转为0；如果是写直达发现错误的块就可以直接丢弃（实现错误检测）。

而写回需要实现错误纠错（这会增加高速缓存的访问时间延迟）。



由于l1高速缓存就是一个最低访问时间延迟，因此采用写直达，功耗比较大。（每个处理器和私有）

因此l2高速缓存就采用写回机制，大小256kb，是为了节省带块。

而l2减小时间延迟也会比较小啊，l2比较大可以降低缓存缺失率。（l3 32m够大了）



l3高速缓存啊是nuca形式的，访问本地时间延迟要比较小，整个cpu一个。

主要为了超线程技术。



八路相联。

cache的一个地址可以放多少个块。

相联度越高，缺失率越低。

但是一个行的块越多，查找越慢，时间延迟越大。



现在一般都是八路相联。

而tlu这种就是全相联。

#### LOCK





对总线和缓存上锁。

强制所有lock信号之前的指令，都在此之前被执行，并同步相关缓存。

执行lock后的指令（如cmpxchg）。

释放对总线和缓存上的锁。

强制所有lock信号之后的指令，都在此之后被执行，并同步相关缓存。



基于总线的

```
// bool cas(uint32 *ptr, uint32 old, uint32 new)
// Atomically:
// if(*val == old){
//    *val = new;
//    return 1;
// } else
//    return 0;
TEXT runtime∕internal∕atomic·Cas(SB), NOSPLIT, $0-17
   MOVD   ptr+0(FP), R3
   MOVWZ  old+8(FP), R4
   MOVWZ  new+12(FP), R5
   LWSYNC
cas_again:
   LWAR   (R3), R6
   CMPW   R6, R4
   BNE    cas_fail
   STWCCC R5, (R3)
   BNE    cas_again
   MOVD   $1, R3
   LWSYNC
   MOVB   R3, ret+16(FP)
   RET
cas_fail:
   MOVB   R0, ret+16(FP)
   RET
```